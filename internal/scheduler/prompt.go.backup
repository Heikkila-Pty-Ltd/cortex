package scheduler

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/antigravity-dev/cortex/internal/beads"
	"github.com/antigravity-dev/cortex/internal/config"
)

var filePathRe = regexp.MustCompile(`(?:^|\s)((?:src|internal|cmd|pkg|lib|app|public|templates|static|test|tests|scripts)/[\w./-]+|[\w-]+\.(?:go|ts|tsx|js|jsx|py|rs|rb|java|vue|svelte|css|scss|html|sql|yaml|yml|toml|json|md|sh))`)

// stageInstructions maps roles to stage-specific prompt instructions.
var stageInstructions = map[string]func(bead beads.Bead, useBranches bool, prDiff string) string{
	"scrum": func(b beads.Bead, useBranches bool, prDiff string) string {
		return fmt.Sprintf(`## Instructions (Scrum Master)
1. Review and refine the task description
2. Add or improve acceptance criteria using: bd update %s --acceptance="..."
3. Break down if too large â€” create sub-tasks with bd create
4. Transition to planning: bd update %s --set-labels stage:planning
5. Unassign yourself: bd update %s --assignee=""
`, b.ID, b.ID, b.ID)
	},
	"planner": func(b beads.Bead, useBranches bool, prDiff string) string {
		return fmt.Sprintf(`## Instructions (Planner)
1. Read the task description and acceptance criteria carefully
2. Create an implementation plan with design notes: bd update %s --design="..."
3. Identify files to create or modify, list them in the design
4. Estimate effort if not set
5. Transition to ready: bd update %s --set-labels stage:ready
6. Unassign yourself: bd update %s --assignee=""
`, b.ID, b.ID, b.ID)
	},
	"coder": func(b beads.Bead, useBranches bool, prDiff string) string {
		shortTitle := b.Title
		if len(shortTitle) > 50 {
			shortTitle = shortTitle[:50]
		}
		pushInstructions := "7. Push: git push"
		if useBranches {
			pushInstructions = "7. Push: git push (PR creation will be handled automatically)"
		}
		return fmt.Sprintf(`## Instructions (Coder)
1. Read the acceptance criteria and design notes carefully
2. Implement in the files listed (create if needed)
3. Run tests if they exist
4. Commit with message: feat(%s): %s
5. Transition to review: bd update %s --set-labels stage:review
6. Unassign yourself: bd update %s --assignee=""
%s
`, b.ID, shortTitle, b.ID, b.ID, pushInstructions)
	},
	"reviewer": func(b beads.Bead, useBranches bool, prDiff string) string {
		diffSection := ""
		if prDiff != "" {
			diffSection = fmt.Sprintf("\n## Pull Request Diff\nReview the following code changes carefully:\n\n```diff\n%s\n```\n", prDiff)
		}

		return fmt.Sprintf(`## Instructions (Reviewer)
1. Review the code changes against acceptance criteria
2. Check for correctness, style, and test coverage%s
3. If approved: transition to QA: bd update %s --set-labels stage:qa
4. If changes needed: add review notes and transition back: bd update %s --set-labels stage:coding
5. Unassign yourself: bd update %s --assignee=""

Note: You can also use 'gh pr review --approve' or 'gh pr review --request-changes' if you have the PR number.
`, diffSection, b.ID, b.ID, b.ID)
	},
	"ops": func(b beads.Bead, useBranches bool, prDiff string) string {
		return fmt.Sprintf(`## Instructions (QA/Ops)
1. Run the full test suite
2. Verify acceptance criteria are met
3. If all tests pass: transition to DoD checking: bd update %s --set-labels stage:dod
4. If tests fail: add failure notes and transition back: bd update %s --set-labels stage:coding
5. When DoD is complete and all criteria met: bd close %s
6. Unassign yourself: bd update %s --assignee=""

Note: The system will automatically run Definition of Done checks after you transition to stage:dod.
`, b.ID, b.ID, b.ID, b.ID)
	},
	"sprint_review": func(b beads.Bead, useBranches bool, prDiff string) string {
		return fmt.Sprintf(`## Instructions (Scrum Master - Sprint Review)

**OBJECTIVE:** Analyze planned vs delivered outcomes for the current sprint and produce a comprehensive narrative summary.

### Sprint Review Analysis Framework

1. **Gather Sprint Data**
   - Review all completed issues: bd list --status=closed --sprint-current
   - Review incomplete issues: bd list --status=open --sprint-current  
   - Calculate velocity metrics and completion percentages
   - Identify scope changes and emergency additions

2. **Planned vs Delivered Analysis**
   - Compare initial sprint commitment to actual deliveries
   - Analyze story point variance and completion rates
   - Document scope creep, descoping decisions, and priority shifts
   - Identify patterns in over/under-estimation

3. **Quality Assessment**
   - Review defect rates and rework cycles
   - Assess technical debt impact on delivery
   - Evaluate testing coverage and quality gate compliance
   - Document production incidents or rollbacks

4. **Stakeholder Impact Analysis**
   - Map delivered features to business value realized
   - Assess customer feedback on delivered functionality
   - Document feature adoption and usage metrics where available
   - Identify stakeholder satisfaction trends

5. **Generate Narrative Summary**
   - Create executive summary of sprint outcomes
   - Highlight significant achievements and roadblocks
   - Provide data-driven insights on team performance trends
   - Include recommendations for stakeholder presentation

6. **Premium Analytical Reasoning** (Opus-tier analysis)
   - Apply pattern recognition across multiple sprint cycles
   - Identify leading indicators for delivery predictability
   - Correlate external factors (holidays, team changes) with performance
   - Generate probabilistic forecasting for upcoming sprints

7. **Documentation and Transition**
   - Update sprint metrics: bd update %s --metrics="[sprint analysis data]"
   - Create follow-up issues for process improvements identified
   - Transition to retrospective if configured: bd update %s --set-labels stage:sprint_retro
   - Close review: bd close %s --reason="Sprint review analysis completed"

**DATA PRESENTATION FORMAT:**
` + "```" + `
Sprint Review Summary - Sprint [N]
========================================
Commitment vs Delivery:
- Planned: [X] story points, [Y] issues
- Delivered: [A] story points, [B] issues  
- Completion Rate: [Z]%%

Key Deliveries:
- [Feature/Epic]: Impact and outcomes
- [Major Bug Fixes]: Customer impact resolved

Missed Commitments:
- [Issue ID]: Reason for miss, revised timeline
- [Scope Changes]: Business justification

Velocity Trends:
- 3-sprint average: [X] points
- Current sprint: [Y] points
- Trend analysis: [increasing/stable/declining]

Quality Metrics:
- Defect rate: [X] bugs per story point
- Rework percentage: [Y]%%%
- Customer satisfaction: [rating/feedback]
` + "```" + `

**ACTIONABLE OUTCOMES:**
Generate specific, measurable action items for:
- Process improvements identified
- Estimation accuracy enhancements
- Quality gate refinements
- Stakeholder communication optimization

Complete when: Comprehensive sprint review analysis is documented with data-driven insights and actionable recommendations.
`, b.ID, b.ID, b.ID)
	},
	"sprint_retro": func(b beads.Bead, useBranches bool, prDiff string) string {
		return fmt.Sprintf(`## Instructions (Scrum Master - Sprint Retrospective)

**OBJECTIVE:** Analyze failures, extract learnings, and generate actionable improvements with systematic pattern analysis.

### Retrospective Analysis Framework

1. **Failure Analysis Deep Dive**
   - Identify all failed commitments, missed deadlines, and quality issues
   - Conduct root cause analysis using 5-Whys methodology  
   - Categorize failures: estimation, technical, process, external dependencies
   - Map failure patterns across team members and work types

2. **Success Pattern Recognition**
   - Document what worked well and exceeded expectations
   - Identify conditions that enabled high-performance outcomes
   - Analyze successful collaboration patterns and tool effectiveness
   - Extract replicable practices and optimal workflows

3. **Team Dynamics Assessment**
   - Evaluate communication effectiveness and knowledge sharing
   - Assess workload distribution and team member satisfaction
   - Identify blockers, friction points, and flow interruptions
   - Review pair programming, code review, and mentoring effectiveness

4. **Process Improvement Identification**
   - Analyze ceremony effectiveness (standups, planning, reviews)
   - Evaluate tool usage and development environment efficiency
   - Review definition of done compliance and quality practices
   - Assess estimation accuracy and planning effectiveness

5. **Learning Extraction & Codification**
   - Document key insights and mental models developed
   - Create decision frameworks for similar future situations  
   - Identify skill gaps and training opportunities
   - Extract principles and heuristics for team playbook

6. **Premium Pattern Analysis** (Opus-tier reasoning)
   - Correlate team performance with external variables
   - Identify leading indicators for sprint success/failure
   - Apply systems thinking to understand interconnected issues
   - Generate predictive insights for risk mitigation

7. **Action Item Generation & Execution**
   - Create specific, measurable, time-bound improvement actions
   - Assign ownership and accountability for each action item
   - Design experiments to validate improvement hypotheses
   - Set up metrics to track improvement effectiveness

8. **Systematic Follow-through**
   - Create follow-up issues for all action items: bd create --title="Retro Action: [description]" --type=improvement
   - Schedule check-ins for action item progress tracking
   - Document improvement results for future retrospective reference
   - Update team working agreements and process documentation

**RETROSPECTIVE DATA STRUCTURE:**
` + "```" + `
Sprint Retrospective Analysis - Sprint [N]
==========================================

FAILURES & ROOT CAUSES:
1. [Issue/Pattern]: 
   - Root Cause: [5-Whys analysis]
   - Impact: [quantified impact]
   - Prevention Strategy: [specific actions]

2. [Technical Debt Impact]:
   - Debt Areas: [specific technical issues]
   - Time Cost: [hours/days lost to debt]
   - Remediation Plan: [concrete steps]

SUCCESSES & AMPLIFICATION:
1. [What Worked Well]:
   - Success Factors: [conditions that enabled success]
   - Replication Strategy: [how to repeat success]

2. [Team Collaboration Wins]:
   - Effective Practices: [specific behaviors/tools]
   - Scaling Approach: [how to expand successful practices]

LEARNING INSIGHTS:
- Key Realizations: [new understanding gained]
- Mental Models: [frameworks developed]
- Decision Principles: [heuristics for future use]

SYSTEMIC PATTERNS:
- Recurring Issues: [patterns across multiple sprints]
- Environmental Factors: [external influences on performance]
- Predictive Indicators: [early warning signs identified]
` + "```" + `

**ACTION ITEM EXECUTION:**
For each improvement identified:
1. Create trackable issue with acceptance criteria
2. Assign clear ownership and timeline
3. Define success metrics and measurement approach
4. Set up automated reminders for progress check-ins
5. Link to relevant process documentation for updates

**AUTO-EXECUTABLE ACTIONS:**
Automatically execute where appropriate:
- Update team working agreements
- Modify ceremony templates based on learnings
- Create recurring reminders for new practices
- Update estimation guidelines and historical data
- Schedule training sessions or knowledge sharing

9. **Documentation and Closure**
   - Update team retrospective learnings database
   - Close retrospective: bd close %s --reason="Retrospective analysis completed with [N] action items generated"
   - Ensure all action items are properly tracked and assigned
   - Schedule next retrospective and set up success metric tracking

Complete when: Comprehensive failure analysis is documented, learnings are extracted and codified, and all actionable improvements are converted into trackable issues with clear ownership.
`, b.ID)
	},
}

// BuildPrompt constructs the prompt sent to an openclaw agent.
func BuildPrompt(bead beads.Bead, project config.Project) string {
	return BuildPromptWithRole(bead, project, "")
}

// BuildPromptWithRole constructs a role-aware prompt sent to an openclaw agent.
func BuildPromptWithRole(bead beads.Bead, project config.Project, role string) string {
	return BuildPromptWithRoleBranches(bead, project, role, false, "")
}

// BuildPromptWithRoleBranches constructs a role-aware prompt with branch workflow support.
func BuildPromptWithRoleBranches(bead beads.Bead, project config.Project, role string, useBranches bool, prDiff string) string {
	var b strings.Builder

	fmt.Fprintf(&b, "You are working on project in %s.\n\n", project.Workspace)
	fmt.Fprintf(&b, "## Task: %s (%s)\n\n", bead.Title, bead.ID)
	fmt.Fprintf(&b, "%s\n\n", bead.Description)

	if bead.Acceptance != "" {
		fmt.Fprintf(&b, "## Acceptance Criteria\n%s\n\n", bead.Acceptance)
	}

	if bead.Design != "" {
		fmt.Fprintf(&b, "## Design Notes\n%s\n\n", bead.Design)
	}

	// Use stage-specific instructions if role is known
	if fn, ok := stageInstructions[role]; ok {
		b.WriteString(fn(bead, useBranches, prDiff))
	} else {
		// Generic fallback (original behavior)
		b.WriteString("## Instructions\n")
		b.WriteString("1. Read the acceptance criteria carefully\n")
		b.WriteString("2. Implement in the files listed (create if needed)\n")
		b.WriteString("3. Run tests if they exist\n")
		shortTitle := bead.Title
		if len(shortTitle) > 50 {
			shortTitle = shortTitle[:50]
		}
		fmt.Fprintf(&b, "4. Commit with message: feat(%s): %s\n", bead.ID, shortTitle)
		fmt.Fprintf(&b, "5. When done, run: bd close %s\n", bead.ID)
		if useBranches {
			b.WriteString("6. Push: git push (PR creation will be handled automatically)\n")
		} else {
			b.WriteString("6. Push: git push\n")
		}
	}
	b.WriteString("\n")

	files := extractFilePaths(bead.Description)
	if len(files) > 0 {
		b.WriteString("## Context Files\n")
		for _, f := range files {
			fmt.Fprintf(&b, "- %s\n", f)
		}
	}

	return b.String()
}

func extractFilePaths(text string) []string {
	matches := filePathRe.FindAllStringSubmatch(text, -1)
	seen := make(map[string]bool)
	var paths []string
	for _, m := range matches {
		p := strings.TrimSpace(m[1])
		if !seen[p] {
			seen[p] = true
			paths = append(paths, p)
		}
	}
	return paths
}
