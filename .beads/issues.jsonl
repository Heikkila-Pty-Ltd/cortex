{"id":"cortex-08z","title":"Phase 1: Cortex Core — Scheduler + Rate Limiter","description":"Working Go binary that reads beads from project dirs, builds dependency graphs, finds unblocked tasks, respects unified rate limits, dispatches openclaw agents, and tracks state in SQLite. This is the core scheduling engine.","status":"closed","priority":2,"issue_type":"epic","owner":"simon.heikkila@gmail.com","estimated_minutes":480,"created_at":"2026-02-17T13:33:07.156580998+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:54:32.932625657+10:00","closed_at":"2026-02-17T14:54:32.932625657+10:00","close_reason":"Phase 1 complete: all 10 tasks done, binary builds and tests pass","labels":["core","phase-1"]}
{"id":"cortex-08z.1","title":"Go module init + project scaffold","description":"Initialize Go module and create the full directory structure:\n\n  go mod init github.com/antigravity-dev/cortex\n  \nCreate all package directories per module layout:\n  cmd/cortex/, internal/config/, internal/beads/, internal/scheduler/,\n  internal/dispatch/, internal/health/, internal/learner/, internal/api/, internal/store/\n\nAdd core dependencies:\n  modernc.org/sqlite (pure-Go SQLite driver)\n  github.com/BurntSushi/toml (config parsing)\n\nCreate minimal main.go with signal handling skeleton (SIGINT/SIGTERM graceful shutdown).\nCreate Makefile with build, install, clean targets.\n\nAcceptance criteria:\n- go build ./cmd/cortex/ produces a working binary\n- Binary starts and exits cleanly on SIGINT\n- All package dirs exist with placeholder .go files","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":30,"created_at":"2026-02-17T13:45:59.053458725+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:40:50.31309257+10:00","closed_at":"2026-02-17T14:40:50.31309257+10:00","close_reason":"Scaffold complete: go mod, all packages, main.go with signal handling, Makefile, deps installed, builds clean","labels":["core","phase-1"],"dependencies":[{"issue_id":"cortex-08z.1","depends_on_id":"cortex-08z","type":"parent-child","created_at":"2026-02-17T13:45:59.057613426+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-08z.10","title":"Main binary entry point + systemd unit","description":"Wire everything together in cmd/cortex/main.go and create the systemd service file.\n\nmain.go:\n1. Parse flags: --config (default: cortex.toml), --once (run single tick then exit, for testing)\n2. Load config via config.Load()\n3. Open store via store.Open(config.StateDB)\n4. Create rateLimiter, dispatcher, scheduler\n5. Start scheduler in goroutine\n6. Block on signal (SIGINT/SIGTERM) for graceful shutdown\n7. On shutdown: cancel context, wait for running tick to finish, close store\n\ncortex.service (systemd user unit):\n  [Unit]\n  Description=Cortex Agent Orchestrator\n  After=openclaw-gateway.service\n\n  [Service]\n  Type=simple\n  ExecStart=%h/projects/cortex/cortex --config %h/projects/cortex/cortex.toml\n  Restart=always\n  RestartSec=10\n  Environment=PATH=%h/.local/bin:/usr/local/bin:/usr/bin\n\n  [Install]\n  WantedBy=default.target\n\nMakefile targets:\n  build: go build -o cortex ./cmd/cortex/\n  install: cp cortex ~/.local/bin/\n  service-install: cp cortex.service ~/.config/systemd/user/ \u0026\u0026 systemctl --user daemon-reload\n  service-start: systemctl --user enable --now cortex.service\n\nAcceptance criteria:\n- cortex binary starts, runs one tick with --once flag, exits cleanly\n- cortex binary runs continuously and responds to SIGTERM\n- systemd unit installs and starts correctly\n- Logs appear in journalctl --user -u cortex.service","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":45,"created_at":"2026-02-17T14:12:41.806052224+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:54:32.551083368+10:00","closed_at":"2026-02-17T14:54:32.551083368+10:00","close_reason":"Main binary, systemd unit, and Makefile all implemented","labels":["core","phase-1"],"dependencies":[{"issue_id":"cortex-08z.10","depends_on_id":"cortex-08z","type":"parent-child","created_at":"2026-02-17T14:12:41.809619678+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-08z.10","depends_on_id":"cortex-08z.9","type":"blocks","created_at":"2026-02-17T14:12:41.815717384+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-08z.2","title":"TOML config loader","description":"Implement internal/config/config.go that parses cortex.toml into typed Go structs.\n\nStructs needed:\n- Config (top-level): General, Projects map, RateLimits, Providers map, Tiers, Health, Reporter, API\n- General: TickInterval (duration), MaxPerTick (int), StuckTimeout (duration), MaxRetries (int), LogLevel (string), StateDB (path)\n- Project: Enabled (bool), BeadsDir (path), Workspace (path), Priority (int)\n- RateLimits: Window5hCap (int), WeeklyCap (int), WeeklyHeadroomPct (int)\n- Provider: Tier (string), Authed (bool), Model (string)\n- Tiers: Fast, Balanced, Premium ([]string provider names)\n- Health: CheckInterval (duration), GatewayUnit (string)\n- Reporter: Channel (string), AgentID (string), DailyDigestTime (string), WeeklyRetroDay (string)\n- API: Bind (string)\n\nValidate on load: all provider names in tiers exist in providers map, at least one project enabled, state_db dir exists.\n\nCreate the default cortex.toml with all providers and hg-website as the initial enabled project.\n\nAcceptance criteria:\n- Config loads from cortex.toml successfully\n- Invalid configs return descriptive errors\n- Unit test covers: valid config, missing required fields, unknown provider in tier","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":60,"created_at":"2026-02-17T13:50:22.592398066+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:48:50.180842457+10:00","closed_at":"2026-02-17T14:48:50.180842457+10:00","close_reason":"Implemented with tests, all passing","labels":["core","phase-1"],"dependencies":[{"issue_id":"cortex-08z.2","depends_on_id":"cortex-08z","type":"parent-child","created_at":"2026-02-17T13:50:22.618547657+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-08z.2","depends_on_id":"cortex-08z.1","type":"blocks","created_at":"2026-02-17T13:50:22.636563313+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-08z.3","title":"SQLite store layer","description":"Implement internal/store/store.go with SQLite operations.\n\nOn first run, auto-create schema:\n- dispatches table (id, bead_id, project, agent_id, provider, tier, pid, prompt, dispatched_at, completed_at, status, exit_code, duration_s, retries, escalated_from_tier)\n- provider_usage table (id, provider, agent_id, bead_id, dispatched_at)\n- health_events table (id, event_type, details, created_at)\n- tick_metrics table (id, tick_at, project, beads_open, beads_ready, dispatched, completed, failed, stuck)\n\nCRUD methods:\n- RecordDispatch(beadID, project, agent, provider, tier, pid, prompt) -\u003e id\n- UpdateDispatchStatus(id, status, exitCode, durationS)\n- GetRunningDispatches() -\u003e []Dispatch\n- GetStuckDispatches(timeout duration) -\u003e []Dispatch\n- RecordProviderUsage(provider, agentID, beadID)\n- CountAuthedUsage5h() -\u003e int\n- CountAuthedUsageWeekly() -\u003e int\n- RecordHealthEvent(eventType, details)\n- RecordTickMetrics(project, open, ready, dispatched, completed, failed, stuck)\n\nIndexes: idx_dispatches_status, idx_dispatches_bead, idx_usage_provider(provider, dispatched_at)\n\nAcceptance criteria:\n- All tables created on first Open()\n- All CRUD methods work with unit tests\n- Concurrent access safe (WAL mode enabled)\n- Database path from config.StateDB","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":90,"created_at":"2026-02-17T13:52:01.773492457+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:52:09.214755913+10:00","closed_at":"2026-02-17T14:52:09.214755913+10:00","close_reason":"Implemented with tests, all passing","labels":["core","phase-1"],"dependencies":[{"issue_id":"cortex-08z.3","depends_on_id":"cortex-08z","type":"parent-child","created_at":"2026-02-17T13:52:01.785318491+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-08z.3","depends_on_id":"cortex-08z.2","type":"blocks","created_at":"2026-02-17T13:52:01.796104448+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-08z.4","title":"Beads CLI wrapper","description":"Implement internal/beads/beads.go that wraps the bd CLI to read bead data from project directories.\n\nFunctions:\n- ListBeads(beadsDir string) -\u003e []Bead, error\n  Runs: bd list --json --quiet in the given directory\n  Parses JSON into Bead structs\n\n- ShowBead(beadsDir, beadID string) -\u003e BeadDetail, error\n  Runs: bd show --json {beadID}\n\n- CloseBead(beadsDir, beadID string) -\u003e error\n  Runs: bd close {beadID}\n\nBead struct fields:\n  ID, Title, Description, Status, Priority, Type, Labels []string,\n  EstimateMinutes int, ParentID string, DependsOn []string,\n  Acceptance string, Design string, CreatedAt time.Time\n\nBuildDepGraph(beads []Bead) -\u003e *DepGraph\n  Builds a directed graph from DependsOn + ParentID edges.\n  \nFilterUnblockedOpen(graph *DepGraph) -\u003e []Bead\n  Returns beads that are: status=open AND all DependsOn beads are closed AND parent is open (not skipped).\n  Sorted by: Priority ASC (P0 first), then EstimateMinutes ASC.\n\nAcceptance criteria:\n- ListBeads correctly parses bd list --json output\n- DepGraph correctly identifies unblocked beads\n- Unit tests with sample JSON fixtures (no actual bd calls)\n- Handles empty bead lists gracefully","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":90,"created_at":"2026-02-17T13:52:33.664382221+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:48:50.205960855+10:00","closed_at":"2026-02-17T14:48:50.205960855+10:00","close_reason":"Implemented with tests, all passing","labels":["core","phase-1"],"dependencies":[{"issue_id":"cortex-08z.4","depends_on_id":"cortex-08z","type":"parent-child","created_at":"2026-02-17T13:52:33.668720161+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-08z.4","depends_on_id":"cortex-08z.1","type":"blocks","created_at":"2026-02-17T13:52:33.674972084+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-08z.5","title":"Unified rate limiter","description":"Implement internal/dispatch/ratelimit.go with the unified authed rate limiter.\n\nCore concept: All authed subscription providers (Claude Max20, OpenAI Pro, Google Pro, Kimi) share two hard gates — a 5h rolling window cap and a weekly cap. Free-tier providers (cerebras, groq) are uncapped.\n\nFunctions:\n- NewRateLimiter(store *store.Store, cfg config.RateLimits) -\u003e *RateLimiter\n- CanDispatchAuthed() -\u003e (bool, string reason)\n  Checks both gates against store.CountAuthedUsage5h() and store.CountAuthedUsageWeekly()\n  Returns false + reason if either gate exceeded\n- RecordAuthedDispatch(provider, agentID, beadID string)\n  Delegates to store.RecordProviderUsage()\n- WeeklyUsagePct() -\u003e float64\n  Returns current weekly usage as percentage of cap\n- IsInHeadroomWarning() -\u003e bool\n  Returns true if WeeklyUsagePct \u003e= config.WeeklyHeadroomPct (default 80%)\n\nAlgorithm for provider selection within a tier:\n- PickProvider(tier string, providers []config.Provider) -\u003e *config.Provider\n  1. If tier is fast -\u003e pick from free providers (no quota check)\n  2. If tier is balanced/premium -\u003e check CanDispatchAuthed()\n  3. If authed gates pass -\u003e return first available provider in tier order\n  4. If gates fail -\u003e return nil (caller handles tier downgrade)\n\nTier downgrade logic (in scheduler, not here):\n  premium -\u003e balanced -\u003e fast, or defer to next tick\n\nAcceptance criteria:\n- 5h rolling window correctly counts dispatches in last 5 hours\n- Weekly rolling window correctly counts dispatches in last 7 days\n- Free-tier providers bypass all gates\n- Headroom warning triggers at configured percentage\n- Unit tests with seeded usage data covering: under cap, at cap, over cap, headroom warning","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":60,"created_at":"2026-02-17T13:52:59.000042143+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:52:58.486999173+10:00","closed_at":"2026-02-17T14:52:58.486999173+10:00","close_reason":"Rate limiter implemented with tests, all passing","labels":["core","phase-1"],"dependencies":[{"issue_id":"cortex-08z.5","depends_on_id":"cortex-08z","type":"parent-child","created_at":"2026-02-17T13:52:59.002997357+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-08z.5","depends_on_id":"cortex-08z.3","type":"blocks","created_at":"2026-02-17T13:52:59.008672868+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-08z.6","title":"Role inference + complexity detection","description":"Implement internal/scheduler/role.go and internal/scheduler/complexity.go.\n\nRole inference (role.go):\n- InferRole(bead Bead) -\u003e string\n  Maps bead labels/type to agent role:\n  | Bead Labels / Type | Role |\n  | Any open bead with code files listed | coder |\n  | Label contains review, test, qa | reviewer |\n  | Label contains deploy, ops, ci | ops |\n  | Type = epic | skip (Cortex tracks epic completion automatically) |\n  | Default | coder |\n  \n- ResolveAgent(project string, role string) -\u003e string\n  Returns '{project}-{role}' (e.g. 'hg-website-coder')\n  Falls back to 'main-{role}' if project-specific agent doesn't exist\n\nComplexity detection (complexity.go):\n- DetectComplexity(bead Bead) -\u003e string (tier: fast|balanced|premium)\n  | Signal | Tier |\n  | estimated_minutes \u003c= 30 | fast |\n  | estimated_minutes 31-90 | balanced |\n  | estimated_minutes \u003e 90 | premium |\n  | Label complex or architecture | premium |\n  | Label trivial or chore | fast |\n  Labels override time-based detection.\n\nAcceptance criteria:\n- Role correctly inferred from labels with priority ordering\n- Complexity correctly maps estimate + labels to tier\n- Label override takes precedence over time estimate\n- Unit tests cover all mapping combinations","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":45,"created_at":"2026-02-17T13:56:22.89995188+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:52:09.244025453+10:00","closed_at":"2026-02-17T14:52:09.244025453+10:00","close_reason":"Implemented with tests, all passing","labels":["core","phase-1"],"dependencies":[{"issue_id":"cortex-08z.6","depends_on_id":"cortex-08z","type":"parent-child","created_at":"2026-02-17T13:56:22.903471817+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-08z.6","depends_on_id":"cortex-08z.4","type":"blocks","created_at":"2026-02-17T13:56:22.908012317+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-08z.7","title":"Agent prompt builder","description":"Implement internal/scheduler/prompt.go that constructs the prompt sent to openclaw agents.\n\nFunction:\n- BuildPrompt(bead Bead, project config.Project) -\u003e string\n\nTemplate:\n  You are working on project {project_name} in {workspace_dir}.\n\n  ## Task: {bead.title} ({bead.id})\n\n  {bead.description}\n\n  ## Acceptance Criteria\n  {bead.acceptance}\n\n  ## Design Notes\n  {bead.design}\n\n  ## Instructions\n  1. Read the acceptance criteria carefully\n  2. Implement in the files listed (create if needed)\n  3. Run tests if they exist\n  4. Commit with message: feat({bead.id}): {short_title}\n  5. When done, run: bd close {bead.id}\n  6. Push: git push\n\n  ## Context Files\n  {extracted file paths from bead description}\n\nFile extraction: scan description for paths matching common patterns (src/, internal/, *.go, *.ts, *.py, etc.)\n\nAcceptance criteria:\n- Prompt includes all bead metadata (title, description, acceptance, design)\n- File paths extracted from description\n- Template is readable and well-structured\n- Unit test verifies template rendering with sample bead","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":30,"created_at":"2026-02-17T13:56:47.58364861+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:52:09.287511394+10:00","closed_at":"2026-02-17T14:52:09.287511394+10:00","close_reason":"Implemented with tests, all passing","labels":["core","phase-1"],"dependencies":[{"issue_id":"cortex-08z.7","depends_on_id":"cortex-08z","type":"parent-child","created_at":"2026-02-17T13:56:47.587726938+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-08z.7","depends_on_id":"cortex-08z.4","type":"blocks","created_at":"2026-02-17T13:56:47.59525896+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-08z.8","title":"OpenClaw agent dispatcher","description":"Implement internal/dispatch/dispatcher.go that wraps the openclaw CLI to dispatch agents.\n\nFunctions:\n- Dispatch(agent string, prompt string, provider string, thinkingLevel string) -\u003e (pid int, error)\n  Runs: openclaw agent --agent {agent} --message {prompt} --thinking {thinkingLevel}\n  Starts process in background, returns PID for tracking.\n  thinkingLevel derived from tier: fast=none, balanced=low, premium=high\n\n- IsProcessAlive(pid int) -\u003e bool\n  Checks if PID is still running via kill -0\n\n- KillProcess(pid int) -\u003e error\n  Sends SIGTERM, waits 5s, then SIGKILL if still alive\n\nEnvironment setup:\n  Ensure openclaw binary is in PATH\n  Set CWD to project workspace directory\n\nAcceptance criteria:\n- Dispatch starts an openclaw agent process and returns valid PID\n- IsProcessAlive correctly reports live/dead processes\n- KillProcess terminates gracefully with fallback to SIGKILL\n- Unit tests mock exec.Command for isolation\n- Integration test (manual): dispatches a real agent with a trivial prompt, confirms PID tracking","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":60,"created_at":"2026-02-17T13:58:10.798997021+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:48:50.233413221+10:00","closed_at":"2026-02-17T14:48:50.233413221+10:00","close_reason":"Implemented with tests, all passing","labels":["core","phase-1"],"dependencies":[{"issue_id":"cortex-08z.8","depends_on_id":"cortex-08z","type":"parent-child","created_at":"2026-02-17T13:58:10.801768094+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-08z.8","depends_on_id":"cortex-08z.1","type":"blocks","created_at":"2026-02-17T13:58:10.857391397+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-08z.9","title":"Core scheduler tick loop","description":"Implement internal/scheduler/scheduler.go — the main orchestration loop that ties everything together.\n\nScheduler struct holds references to: config, store, rateLimiter, dispatcher, logger.\n\nRunTick() method (called every config.TickInterval):\n1. For each enabled project (sorted by priority):\n   a. beads = ListBeads(project.BeadsDir)\n   b. graph = BuildDepGraph(beads)\n   c. ready = FilterUnblockedOpen(graph)\n   d. Record tick metrics (beads_open, beads_ready counts)\n   \n2. For each ready bead (up to maxPerTick across all projects):\n   a. Skip if alreadyDispatched (check store.GetRunningDispatches)\n   b. role = InferRole(bead) — skip if epic\n   c. tier = DetectComplexity(bead)\n   d. provider = rateLimiter.PickProvider(tier)\n   e. If provider nil: try tier downgrade (premium-\u003ebalanced-\u003efast), log if all exhausted\n   f. prompt = BuildPrompt(bead, project)\n   g. agent = ResolveAgent(project.Name, role)\n   h. pid = dispatcher.Dispatch(agent, prompt, provider, thinkingLevel)\n   i. store.RecordDispatch(bead.ID, project.Name, agent, provider, tier, pid, prompt)\n   j. rateLimiter.RecordAuthedDispatch(provider) if authed\n   \n3. CheckRunningDispatches():\n   a. For each running dispatch in store:\n   b. If PID dead -\u003e mark completed or failed based on exit code\n   c. Record duration\n\nStart() method:\n  Runs RunTick in a goroutine on a ticker, respects context cancellation for graceful shutdown.\n\nAcceptance criteria:\n- Tick loop iterates projects by priority\n- Respects maxPerTick limit across all projects\n- Skips already-dispatched beads (no double dispatch)\n- Tier downgrade works: premium-\u003ebalanced-\u003efast\n- Running dispatch status polling detects completed/failed\n- Integration test: mock all deps, verify dispatch sequence with sample beads\n- Structured logging (slog) for each dispatch decision","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":120,"created_at":"2026-02-17T14:07:02.448542707+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:53:43.738555982+10:00","closed_at":"2026-02-17T14:53:43.738555982+10:00","close_reason":"Scheduler tick loop implemented, all tests pass","labels":["core","phase-1"],"dependencies":[{"issue_id":"cortex-08z.9","depends_on_id":"cortex-08z","type":"parent-child","created_at":"2026-02-17T14:07:02.453104918+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-08z.9","depends_on_id":"cortex-08z.3","type":"blocks","created_at":"2026-02-17T14:07:02.459620762+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-08z.9","depends_on_id":"cortex-08z.4","type":"blocks","created_at":"2026-02-17T14:07:02.463452132+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-08z.9","depends_on_id":"cortex-08z.5","type":"blocks","created_at":"2026-02-17T14:07:02.467106582+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-08z.9","depends_on_id":"cortex-08z.6","type":"blocks","created_at":"2026-02-17T14:07:02.470851552+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-08z.9","depends_on_id":"cortex-08z.7","type":"blocks","created_at":"2026-02-17T14:07:02.474640783+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-08z.9","depends_on_id":"cortex-08z.8","type":"blocks","created_at":"2026-02-17T14:07:02.478246162+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-0kw","title":"Phase 5: Status API + Polish","description":"HTTP status endpoints (/status, /projects/{id}, /health, /metrics), Makefile with build/install/service-install targets, graceful shutdown, structured logging (slog), README.md with architecture overview.","status":"closed","priority":2,"issue_type":"epic","owner":"simon.heikkila@gmail.com","estimated_minutes":240,"created_at":"2026-02-17T13:40:32.974740877+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T15:03:00.339150723+10:00","closed_at":"2026-02-17T15:03:00.339150723+10:00","close_reason":"Closed","labels":["api","phase-5","polish"]}
{"id":"cortex-0kw.1","title":"HTTP status API","description":"Implement internal/api/api.go — lightweight HTTP API for querying Cortex state.\n\nEndpoints:\n- GET /status -\u003e overall Cortex status (uptime, last tick, dispatches running, rate limiter state)\n- GET /projects -\u003e list of enabled projects with bead counts (open, ready, running, completed)\n- GET /projects/{id} -\u003e detailed project view: recent dispatches, ready beads, velocity\n- GET /health -\u003e health check summary: gateway status, recent health events, stuck count\n- GET /metrics -\u003e Prometheus-compatible metrics: dispatches_total, dispatches_failed_total, rate_limiter_usage_ratio, tick_duration_seconds\n\nServer:\n- net/http stdlib (no framework needed for 5 endpoints)\n- Bind to config.API.Bind (default 127.0.0.1:8900)\n- JSON responses with proper Content-Type headers\n- Starts as goroutine from main.go, shutdown via context cancellation\n\nAcceptance criteria:\n- All 5 endpoints return valid JSON\n- /health returns 200 when healthy, 503 when gateway down\n- /metrics compatible with Prometheus scraping format\n- Server starts on configured bind address\n- Graceful shutdown on context cancellation\n- Unit tests for each endpoint handler with mock store data","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":60,"created_at":"2026-02-17T14:25:40.41699718+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T15:01:50.741273815+10:00","closed_at":"2026-02-17T15:01:50.741273815+10:00","close_reason":"Closed","labels":["api","phase-5"],"dependencies":[{"issue_id":"cortex-0kw.1","depends_on_id":"cortex-0kw","type":"parent-child","created_at":"2026-02-17T14:25:40.443618494+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-0kw.1","depends_on_id":"cortex-08z.3","type":"blocks","created_at":"2026-02-17T14:25:40.487881873+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-0kw.1","depends_on_id":"cortex-08z.10","type":"blocks","created_at":"2026-02-17T14:25:40.506134929+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-0kw.2","title":"Structured logging with slog","description":"Replace all fmt.Printf/log.Printf calls with Go's structured logging (log/slog).\n\nSetup:\n- Configure slog in main.go based on config.LogLevel (debug/info/warn/error)\n- Use slog.With() for per-component loggers: scheduler, dispatcher, health, api, learner\n- JSON output format for machine parsing, text format for development (--dev flag)\n\nLog key events with structured fields:\n- Dispatch: bead_id, project, agent, provider, tier, pid\n- Completion: bead_id, duration_s, exit_code, status\n- Rate limit: tier, usage_5h, usage_weekly, cap_5h, cap_weekly\n- Health: event_type, details, action_taken\n- Tick: project, beads_open, beads_ready, dispatched_count\n\nAcceptance criteria:\n- All log output uses slog with structured fields\n- Log level configurable via cortex.toml\n- JSON format in production, text in dev\n- No raw fmt.Printf left in non-test code\n- Logs parseable by standard log aggregators","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":30,"created_at":"2026-02-17T14:26:00.96225876+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T15:01:50.781848424+10:00","closed_at":"2026-02-17T15:01:50.781848424+10:00","close_reason":"Closed","labels":["phase-5","polish"],"dependencies":[{"issue_id":"cortex-0kw.2","depends_on_id":"cortex-0kw","type":"parent-child","created_at":"2026-02-17T14:26:01.00291675+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-0kw.2","depends_on_id":"cortex-08z.10","type":"blocks","created_at":"2026-02-17T14:26:01.074752193+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-0kw.3","title":"Graceful shutdown + README","description":"Polish the binary for production use.\n\nGraceful shutdown (enhance main.go):\n1. On SIGTERM/SIGINT: set shutdown flag\n2. Wait for any in-progress tick to complete (don't kill mid-dispatch)\n3. Close HTTP API server with context timeout (5s)\n4. Close SQLite store cleanly\n5. Log shutdown reason and duration\n\nREADME.md:\n- Architecture overview with ASCII diagram from plan\n- Quick start: build, configure cortex.toml, install systemd unit, start\n- Configuration reference: all cortex.toml sections with defaults\n- Provider setup: how to add/remove providers\n- Project setup: how to enable a new project (beads dir, workspace, agent creation)\n- Monitoring: how to query the HTTP API, where logs go\n- Troubleshooting: common issues (gateway down, rate limit hit, stuck tasks)\n\nAcceptance criteria:\n- Binary handles shutdown cleanly in all states (idle, mid-tick, mid-dispatch)\n- README covers all sections listed above\n- README is accurate to the actual implementation\n- No orphan processes left on shutdown","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":45,"created_at":"2026-02-17T14:26:28.456959192+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T15:03:00.120347648+10:00","closed_at":"2026-02-17T15:03:00.120347648+10:00","close_reason":"Closed","labels":["phase-5","polish"],"dependencies":[{"issue_id":"cortex-0kw.3","depends_on_id":"cortex-0kw","type":"parent-child","created_at":"2026-02-17T14:26:28.712913955+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-0kw.3","depends_on_id":"cortex-0kw.1","type":"blocks","created_at":"2026-02-17T14:26:28.73566296+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-0kw.3","depends_on_id":"cortex-0kw.2","type":"blocks","created_at":"2026-02-17T14:26:28.741505263+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-1b2","title":"Wire TmuxDispatcher into scheduler","description":"Replace *dispatch.Dispatcher with *dispatch.TmuxDispatcher in scheduler.go and main.go. Change dispatch tracking from PID (int) to session name (string). Update store.RecordDispatch and store.GetRunningDispatches to use session names. Update checkRunningDispatches to use SessionStatus() instead of IsProcessAlive(). The TmuxDispatcher already exists in internal/dispatch/tmux.go with full Dispatch/SessionStatus/CaptureOutput/KillSession methods.","status":"open","priority":0,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:57:08.716910567+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:57:08.716910567+10:00","labels":["code","stage:backlog"],"dependencies":[{"issue_id":"cortex-1b2","depends_on_id":"cortex-j5d","type":"parent-child","created_at":"2026-02-17T17:57:21.688315317+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-255","title":"Operational resilience improvements","description":"Several reliability gaps in the current implementation: ungraceful shutdown (500ms hardcoded sleep), fragile zombie detection via pgrep, simplistic retry strategy (always escalate tier), no backoff.\n\nKey deliverables:\n- Graceful shutdown: wait for running dispatches to complete (with timeout)\n- Smarter retry: exponential backoff, not just tier escalation\n- Zombie detection via tmux session list (replaces fragile pgrep)\n- Startup validation: verify config completeness before starting\n- Signal handling: SIGUSR1 for state dump","status":"open","priority":2,"issue_type":"epic","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:57:33.623757994+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:57:33.623757994+10:00"}
{"id":"cortex-255.1","title":"Implement graceful shutdown with dispatch draining","description":"Replace the 500ms hardcoded sleep with proper graceful shutdown that waits for running dispatches.\n\nChanges to cmd/cortex/main.go:\n- On SIGINT/SIGTERM: cancel context, then wait for goroutines\n- Use sync.WaitGroup for scheduler, health monitor, API server\n- Add shutdown timeout (configurable, default 60s)\n- If timeout reached, log warning and force exit\n\nChanges to internal/scheduler/scheduler.go:\n- On context cancellation: stop accepting new ticks\n- Wait for any in-progress tick to complete\n- Log: 'scheduler shutdown: N dispatches still running'\n\nChanges to internal/api/api.go:\n- Use http.Server.Shutdown(ctx) for graceful HTTP shutdown\n\nConfig:\n```toml\n[general]\nshutdown_timeout = \"60s\"\n```\n\nAcceptance: Clean shutdown waits for in-progress work, timeout prevents hanging, all goroutines tracked","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:28.12110888+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:28.12110888+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-255.1","depends_on_id":"cortex-255","type":"parent-child","created_at":"2026-02-17T18:00:28.125714686+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-255.2","title":"Implement exponential backoff retry strategy","description":"Replace the simplistic 'always escalate tier' retry with intelligent backoff.\n\nCurrent behavior (health/stuck.go): stuck dispatch → kill → escalate tier → retry immediately.\nProblem: if the task is genuinely impossible, we burn through all tiers quickly.\n\nNew retry strategy (internal/dispatch/retry.go):\n```go\ntype RetryPolicy struct {\n    MaxRetries     int\n    InitialDelay   time.Duration  // delay before first retry\n    BackoffFactor  float64        // multiply delay each retry\n    MaxDelay       time.Duration  // cap on delay\n    EscalateAfter  int            // escalate tier after N same-tier failures\n}\n\n// DefaultPolicy returns sensible defaults\nfunc DefaultPolicy() RetryPolicy {\n    return RetryPolicy{\n        MaxRetries:    3,\n        InitialDelay:  5 * time.Minute,\n        BackoffFactor: 2.0,\n        MaxDelay:      30 * time.Minute,\n        EscalateAfter: 2,  // try same tier twice before escalating\n    }\n}\n\n// NextRetry calculates when and how to retry\nfunc (p RetryPolicy) NextRetry(attempt int, currentTier string) (delay time.Duration, tier string, shouldRetry bool)\n```\n\nStore additions:\n- Add next_retry_at column to dispatches (nullable)\n- Scheduler skips bead if next_retry_at is in the future\n\nIntegration:\n- stuck.go uses RetryPolicy instead of hardcoded escalation\n- Different policies possible per tier or per project (config extension)\n\nAcceptance: Retries back off exponentially, tier escalation delayed, configurable policy","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:35.35983923+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:35.35983923+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-255.2","depends_on_id":"cortex-255","type":"parent-child","created_at":"2026-02-17T18:00:35.363108233+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-255.3","title":"Add startup config validation","description":"Validate config completeness and correctness before starting the scheduler.\n\nCreate internal/config/validate.go:\n```go\nfunc ValidateRuntime(cfg *Config) []ValidationError\n\ntype ValidationError struct {\n    Field   string\n    Message string\n    Fatal   bool   // if true, cannot start\n}\n```\n\nChecks:\n- State DB parent directory exists and is writable\n- At least one project enabled\n- At least one provider defined per referenced tier\n- BeadsDir exists and contains .beads data for each enabled project\n- Workspace directories exist\n- openclaw binary is in PATH\n- tmux binary is in PATH (if TmuxDispatcher selected)\n- API bind port is available (try listen, close)\n- No circular dependencies in tier definitions\n\nOn validation failure:\n- Fatal errors: log and exit with clear message\n- Warnings: log and continue\n\nRun validation in main.go before starting goroutines.\n\nAcceptance: All checks run on startup, fatal errors prevent start, clear error messages","status":"open","priority":3,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:40.710272932+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:40.710272932+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-255.3","depends_on_id":"cortex-255","type":"parent-child","created_at":"2026-02-17T18:00:40.71300238+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-255.4","title":"Add SIGUSR1 state dump","description":"On SIGUSR1 signal, dump current state to log for debugging.\n\nChanges to cmd/cortex/main.go:\n- Add SIGUSR1 handler\n\nState dump includes:\n- Current time, uptime\n- Scheduler: paused?, last tick time, next tick time\n- Running dispatches: count, list of (bead, agent, duration, PID/session)\n- Rate limiter: 5h usage/cap, weekly usage/cap, headroom status\n- Per-project: open beads, ready beads, in-progress, blocked\n- Health: gateway status, restarts in last hour\n- Memory: goroutine count, heap alloc (runtime.MemStats)\n\nOutput: structured JSON to log (slog.Info with all fields).\nAlso write to /tmp/cortex-state-dump.json for easy access.\n\nAcceptance: SIGUSR1 produces comprehensive state dump, readable in logs and file","status":"open","priority":3,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:45.829668458+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:45.829668458+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-255.4","depends_on_id":"cortex-255","type":"parent-child","created_at":"2026-02-17T18:00:45.833747932+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-2px","title":"Git workflow: branches, PRs, and review","description":"Agents push directly to whatever branch they're on. No feature branches, no PRs, no diff visibility. The reviewer agent can't actually review a PR because there isn't one. No rollback mechanism if an agent breaks something.\n\nKey deliverables:\n- Feature branch per bead (git checkout -b feat/{bead-id})\n- PR creation on stage completion (gh pr create)\n- Reviewer agent reviews actual PR diffs (structured code review)\n- Merge gating: only merge after reviewer approves\n- Rollback: revert if post-merge checks fail\n- Diff capture: store what changed per dispatch for audit trail","status":"open","priority":1,"issue_type":"epic","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:57:33.200443457+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:57:33.200443457+10:00"}
{"id":"cortex-2px.1","title":"Implement feature branch creation per bead","description":"Automatically create a feature branch for each bead before dispatching an agent.\n\nCreate internal/git/branch.go:\n```go\n// CreateFeatureBranch creates and checks out a branch for a bead\n// Branch name: feat/{bead-id} (e.g. feat/cortex-abc)\nfunc CreateFeatureBranch(workspace, beadID, baseBranch string) error\n\n// GetCurrentBranch returns the current branch name\nfunc GetCurrentBranch(workspace string) (string, error)\n\n// BranchExists checks if a branch already exists\nfunc BranchExists(workspace, branch string) (bool, error)\n\n// EnsureFeatureBranch creates branch if not exists, checks out if exists\nfunc EnsureFeatureBranch(workspace, beadID string) error\n```\n\nConfig:\n```toml\n[projects.hg-website]\nbase_branch = \"main\"          # branch to create features from\nbranch_prefix = \"feat/\"        # prefix for feature branches\nuse_branches = true            # enable branch workflow (default false for backward compat)\n```\n\nScheduler integration:\n- Before dispatching, call EnsureFeatureBranch if use_branches=true\n- Agent works on the feature branch, not main\n- Update prompt to NOT include 'git push' — PR creation handles that\n\nAcceptance: Feature branches created per bead, agent works on branch, backward compatible when use_branches=false","status":"open","priority":1,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:59:34.313610422+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:59:34.313610422+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-2px.1","depends_on_id":"cortex-2px","type":"parent-child","created_at":"2026-02-17T17:59:34.318199416+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-2px.2","title":"Implement PR creation on stage completion","description":"Automatically create a GitHub PR when the coder agent completes its work.\n\nCreate internal/git/pr.go:\n```go\n// CreatePR creates a pull request for a feature branch\nfunc CreatePR(workspace, branch, baseBranch, title, body string) (prURL string, prNumber int, err error)\n// Uses: gh pr create --head {branch} --base {baseBranch} --title {title} --body {body}\n\n// GetPRStatus checks if a PR exists and its status\nfunc GetPRStatus(workspace, branch string) (*PRStatus, error)\n// Uses: gh pr view {branch} --json state,reviewDecision,number,url\n\ntype PRStatus struct {\n    Number         int\n    URL            string\n    State          string   // OPEN, CLOSED, MERGED\n    ReviewDecision string   // APPROVED, CHANGES_REQUESTED, REVIEW_REQUIRED\n}\n```\n\nTrigger: when coder agent completes (stage:coding → stage:review), create PR.\nPR body includes: bead title, description, acceptance criteria, link to bead.\nStore PR URL and number in dispatches or new pr_tracking table.\n\nAcceptance: PR auto-created after coding stage, PR info stored, gh CLI used","status":"open","priority":1,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:59:44.96383625+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:59:44.96383625+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-2px.2","depends_on_id":"cortex-2px","type":"parent-child","created_at":"2026-02-17T17:59:44.967010247+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-2px.2","depends_on_id":"cortex-2px.1","type":"blocks","created_at":"2026-02-17T18:00:15.892878007+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-2px.3","title":"Reviewer agent reviews actual PR diffs","description":"Update the reviewer agent's prompt to review the actual PR diff instead of just the bead description.\n\n**What is code:** Fetching PR diff, adding to prompt.\n**What is LLM:** The actual code review.\n\nChanges to prompt building:\n- When role=reviewer and a PR exists, fetch diff: gh pr diff {number}\n- Include diff in reviewer prompt: 'Review the following code changes...'\n- Include PR conversation if any comments exist\n\nCreate internal/git/diff.go:\n```go\n// GetPRDiff returns the diff for a PR\nfunc GetPRDiff(workspace string, prNumber int) (string, error)\n// Uses: gh pr diff {number}\n\n// Truncate diff if \u003e50KB (too large for prompt)\nfunc TruncateDiff(diff string, maxBytes int) string\n```\n\nReviewer prompt update (internal/scheduler/prompt.go):\n- Add PR diff section to reviewer stage instructions\n- Include file list and stats\n- Ask reviewer to: approve (gh pr review --approve) or request changes (gh pr review --request-changes)\n\nAcceptance: Reviewer sees actual diff, reviews code not just description, can approve/request changes","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:59:55.105698777+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:59:55.105698777+10:00","dependencies":[{"issue_id":"cortex-2px.3","depends_on_id":"cortex-2px","type":"parent-child","created_at":"2026-02-17T17:59:55.109299999+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-2px.3","depends_on_id":"cortex-2px.2","type":"blocks","created_at":"2026-02-17T18:00:21.861504922+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-2px.4","title":"Implement merge gating and post-merge validation","description":"Only merge PRs after reviewer approves. Run post-merge validation. Rollback if checks fail.\n\nCreate internal/git/merge.go:\n```go\n// MergePR merges an approved PR\nfunc MergePR(workspace string, prNumber int, method string) error\n// Uses: gh pr merge {number} --squash (or --merge)\n// method from config: squash, merge, rebase\n\n// RevertMerge reverts the last merge commit\nfunc RevertMerge(workspace, commitSHA string) error\n// Uses: git revert {sha} --no-edit \u0026\u0026 git push\n\n// RunPostMergeChecks runs DoD checks after merge\nfunc RunPostMergeChecks(workspace string, checks []string) (*DoDResult, error)\n```\n\nWorkflow:\n1. Reviewer approves PR → scheduler detects approval on next tick\n2. Merge PR (squash by default)\n3. Run post-merge validation (DoD checks on main branch)\n4. If checks pass → close bead\n5. If checks fail → revert merge, reopen bead, notify scrum master\n\nConfig:\n```toml\n[projects.hg-website]\nmerge_method = \"squash\"\npost_merge_checks = [\"go test ./...\", \"go vet ./...\"]\nauto_revert_on_failure = true\n```\n\nAcceptance: PRs only merge after approval, post-merge checks run, auto-revert on failure","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:05.811713+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:05.811713+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-2px.4","depends_on_id":"cortex-2px","type":"parent-child","created_at":"2026-02-17T18:00:05.814776129+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-2px.4","depends_on_id":"cortex-2px.3","type":"blocks","created_at":"2026-02-17T18:00:25.130866488+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-2px.5","title":"Store git diffs and change audit trail","description":"Capture and store what each dispatch changed for audit and analysis.\n\nDB additions:\n```sql\nCREATE TABLE dispatch_changes (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    dispatch_id INTEGER NOT NULL REFERENCES dispatches(id),\n    files_changed INTEGER,\n    insertions INTEGER,\n    deletions INTEGER,\n    diff_stat TEXT,      -- git diff --stat output\n    commit_shas TEXT,    -- JSON array of commit SHAs\n    pr_number INTEGER,\n    pr_url TEXT,\n    captured_at TEXT NOT NULL\n);\n```\n\nCapture trigger: on dispatch completion, run in workspace:\n- git log --oneline {base}..HEAD → commit SHAs\n- git diff --stat {base}..HEAD → change stats\n- Store in dispatch_changes\n\nAPI: GET /dispatches/{id}/changes — returns diff stats, commit list, PR info.\n\nUse in retro: 'agent X changed 500 lines across 12 files for a trivial bead — possible over-engineering'\n\nAcceptance: Changes captured per dispatch, stored, queryable via API","status":"open","priority":3,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:11.530799638+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:11.530799638+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-2px.5","depends_on_id":"cortex-2px","type":"parent-child","created_at":"2026-02-17T18:00:11.541531793+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-2px.5","depends_on_id":"cortex-2px.1","type":"blocks","created_at":"2026-02-17T18:00:30.548136789+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-64i","title":"Implement CLI fallback within tier before tier downgrade","description":"Update rate limiter / provider selection to try alternative CLIs within the same tier before falling back to tier downgrade.\n\nFallback order:\n- balanced: claude → codex → (tier downgrade to fast)\n- premium: claude → codex → kimi → (tier downgrade to balanced)\n- fast: kilo → aider → codex/spark → (tier upgrade to balanced)\n\nDetection: if dispatch exits non-zero within 10 seconds of start, treat as 'CLI broken' (not 'task failed'). Immediately retry with next CLI in tier. If all CLIs in tier exhausted, then tier downgrade.\n\nTrack CLI failures in provider_usage or new table. Learner reports on CLI reliability.\n\nAcceptance: broken CLI (missing binary, auth expired) doesn't block dispatch. Falls through to working CLI.","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:43.607000346+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:43.607000346+10:00"}
{"id":"cortex-66n","title":"Update learner to analyze captured dispatch output","description":"Update internal/learner/ to read captured output from dispatch logs:\n\n- On dispatch completion, read log_path from dispatches table\n- Parse output for common failure patterns (compilation errors, test failures, permission denied, auth errors)\n- Add to ProviderStats: common failure categories per provider/CLI\n- Add to weekly retro: output-based recommendations (e.g. 'kilo fails on complex refactors, consider promoting to balanced tier')\n- Compare kilo vs aider success rates on fast tier (the A/B test)\n\nAcceptance: learner reads dispatch logs, categorizes failures, retro includes CLI comparison data.","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:01:04.072090409+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:01:04.072090409+10:00"}
{"id":"cortex-80e","title":"Phase 3: Self-Propelling Pipeline","description":"Multi-dispatch per tick (up to max_per_tick=3), auto-advance stuck stage labels, pipeline flush when downstream has 0 tasks but upstream completed, immediate child-unblock detection on bd close.","status":"closed","priority":2,"issue_type":"epic","owner":"simon.heikkila@gmail.com","estimated_minutes":240,"created_at":"2026-02-17T13:38:38.32962461+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:56:18.952234779+10:00","closed_at":"2026-02-17T14:56:18.952234779+10:00","close_reason":"Phase 3 complete","labels":["phase-3","pipeline"]}
{"id":"cortex-80e.1","title":"Multi-dispatch per tick","description":"Enhance the scheduler tick loop to dispatch up to max_per_tick (default 3) agents per tick across all projects, rather than just 1.\n\nChanges to scheduler.go RunTick():\n1. Collect all ready beads across all enabled projects into a single priority-sorted queue\n2. Dispatch up to max_per_tick from that merged queue\n3. Respect per-project ordering (higher priority project's beads sort first)\n4. If rate limiter blocks authed dispatch, still try free-tier beads from the queue\n5. Log: 'Dispatched {n}/{max} this tick, {remaining} ready beads queued'\n\nAlso add configurable per-project max_concurrent (default: 2) to prevent one project hogging all slots.\n\nAcceptance criteria:\n- Multiple agents dispatched in single tick when beads available\n- Per-project concurrent limit respected\n- Free-tier dispatches not blocked by authed rate limit exhaustion\n- Integration test with multiple projects and beads verifies dispatch ordering","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":60,"created_at":"2026-02-17T14:21:03.114718461+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:56:18.675554601+10:00","closed_at":"2026-02-17T14:56:18.675554601+10:00","close_reason":"Pipeline features implemented","labels":["phase-3","pipeline"],"dependencies":[{"issue_id":"cortex-80e.1","depends_on_id":"cortex-80e","type":"parent-child","created_at":"2026-02-17T14:21:03.286932177+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-80e.1","depends_on_id":"cortex-08z.9","type":"blocks","created_at":"2026-02-17T14:21:03.352634985+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-80e.2","title":"Immediate child-unblock detection","description":"When a dispatch completes (detected during CheckRunningDispatches), immediately check if any of the completed bead's children/dependents are now unblocked, rather than waiting for the next tick.\n\nChanges:\n1. After marking a dispatch as completed in CheckRunningDispatches():\n   a. Get the bead ID that was just closed\n   b. Re-run ListBeads + BuildDepGraph for that project\n   c. Filter newly unblocked beads (beads whose last blocking dep was the just-completed bead)\n   d. If any newly unblocked AND within max_per_tick budget: dispatch immediately\n2. Log: 'Bead {id} completed, {n} children now unblocked, dispatching {m}'\n\nThis creates a reactive chain: as agents close beads, Cortex immediately picks up the next work without waiting 60s.\n\nAcceptance criteria:\n- Completing a bead triggers immediate check for newly unblocked children\n- Newly unblocked beads dispatched within same tick cycle\n- Still respects rate limits and max_per_tick\n- Does not re-dispatch already-running beads\n- Unit test: complete parent bead, verify child gets dispatched","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":45,"created_at":"2026-02-17T14:22:23.894750453+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:56:18.706061805+10:00","closed_at":"2026-02-17T14:56:18.706061805+10:00","close_reason":"Pipeline features implemented","labels":["phase-3","pipeline"],"dependencies":[{"issue_id":"cortex-80e.2","depends_on_id":"cortex-80e","type":"parent-child","created_at":"2026-02-17T14:22:23.946003135+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-80e.2","depends_on_id":"cortex-08z.9","type":"blocks","created_at":"2026-02-17T14:22:23.988987021+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-80e.3","title":"Pipeline flush for stalled downstreams","description":"Detect when a project's downstream beads have 0 open tasks but upstream beads have been completed, indicating the pipeline has stalled at a stage transition.\n\nLogic:\n1. After each tick, for each project:\n   a. Group beads by epic/parent\n   b. If an epic has all children closed -\u003e auto-close the epic via bd close\n   c. If all beads in a dependency chain are closed but the chain's root epic is still open -\u003e close it\n2. This prevents epics from staying open forever when all their children are done.\n\nAlso handle stage label advancement:\n- If a bead has label 'ready' and gets dispatched -\u003e could optionally update label to 'in-progress' via bd CLI\n- On completion -\u003e label updated to 'done' (or just bd close handles this)\n\nAcceptance criteria:\n- Epics auto-closed when all children are closed\n- No false positives (don't close epics with open children)\n- Handles nested epics (epic with child epics)\n- Unit test with sample bead graphs verifying auto-close logic","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":45,"created_at":"2026-02-17T14:22:41.309838405+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:56:18.726626735+10:00","closed_at":"2026-02-17T14:56:18.726626735+10:00","close_reason":"Pipeline features implemented","labels":["phase-3","pipeline"],"dependencies":[{"issue_id":"cortex-80e.3","depends_on_id":"cortex-80e","type":"parent-child","created_at":"2026-02-17T14:22:41.335299436+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-80e.3","depends_on_id":"cortex-08z.4","type":"blocks","created_at":"2026-02-17T14:22:41.356206295+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-80e.3","depends_on_id":"cortex-08z.9","type":"blocks","created_at":"2026-02-17T14:22:41.368733091+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-88b","title":"Phase 0: Cleanup \u0026 Archive Legacy Orchestration","description":"Archive all redundant orchestration tooling that Cortex replaces. Move to ~/backups/orchestration-legacy/. Disable old systemd services.","status":"closed","priority":2,"issue_type":"epic","owner":"simon.heikkila@gmail.com","estimated_minutes":30,"created_at":"2026-02-17T13:32:56.868558981+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:48:51.439494801+10:00","closed_at":"2026-02-17T14:48:51.439494801+10:00","close_reason":"Phase 0 complete","labels":["cleanup","phase-0"]}
{"id":"cortex-88b.1","title":"Archive redundant repos and scripts","description":"Create ~/backups/orchestration-legacy/ directory. Move: ~/orchestration/ (nearly empty), ~/gateway-monitor/ (redundant simple health script), ~/projects/command-center/ (FastAPI dashboard, replaced by Cortex API), select clawd scripts (auditor-check.sh, pane-babysitter.sh, flywheel-monitor.sh), clawd prompts (commander.md, coo-agent.md, project-auditor.md). Write ~/backups/orchestration-legacy/README.md documenting what was archived and why.\n\nAcceptance criteria:\n- All listed dirs/files moved to backup location\n- README.md describes each archived item\n- No broken symlinks left behind\n- Original locations cleaned up","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":15,"created_at":"2026-02-17T13:40:48.238110194+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:48:50.527087372+10:00","closed_at":"2026-02-17T14:48:50.527087372+10:00","close_reason":"Legacy dirs archived, services disabled","labels":["cleanup","phase-0"],"dependencies":[{"issue_id":"cortex-88b.1","depends_on_id":"cortex-88b","type":"parent-child","created_at":"2026-02-17T13:40:48.2410416+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-88b.2","title":"Disable legacy systemd services","description":"Stop and disable the old orchestration services that Cortex replaces:\n- openclaw-workflow.service (heartbeat orchestrator)\n- openclaw-workflow.timer (5-min trigger)\n\nCommands:\n  systemctl --user stop openclaw-workflow.timer openclaw-workflow.service\n  systemctl --user disable openclaw-workflow.timer openclaw-workflow.service\n\nAcceptance criteria:\n- Both services stopped and disabled\n- systemctl --user list-timers shows no openclaw-workflow entry\n- Gateway service (openclaw-gateway.service) remains running (Cortex uses it)","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":10,"created_at":"2026-02-17T13:41:23.335249561+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:48:50.591854037+10:00","closed_at":"2026-02-17T14:48:50.591854037+10:00","close_reason":"Legacy dirs archived, services disabled","labels":["cleanup","phase-0"],"dependencies":[{"issue_id":"cortex-88b.2","depends_on_id":"cortex-88b","type":"parent-child","created_at":"2026-02-17T13:41:23.340020989+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-8yz","title":"Add failure diagnostics to dispatch completion","description":"When a dispatch session exits with non-zero exit code, mark it as 'failed' instead of 'completed'. Parse the captured output for common error patterns (compilation errors, test failures, permission denied, bd command failures). Store a short failure_reason summary in the dispatches table (add column if needed). Log failure details at WARN level. This enables the scheduler to eventually retry or reassign failed beads.","status":"open","priority":1,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:57:15.917636955+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:57:15.917636955+10:00","labels":["code","stage:backlog"],"dependencies":[{"issue_id":"cortex-8yz","depends_on_id":"cortex-kib","type":"blocks","created_at":"2026-02-17T17:57:20.673386318+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-8yz","depends_on_id":"cortex-j5d","type":"parent-child","created_at":"2026-02-17T17:57:22.14246074+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-a4s","title":"Scrum master as project point-of-contact via Matrix","description":"Make the scrum master agent the human-facing communication interface for each project, communicating bidirectionally via Matrix.\n\nCurrently the scrum master silently refines tasks, and the Reporter sends generic digests through a 'main' agent. These are disconnected. The scrum master should OWN the communication loop for its project:\n\n**Outbound (scrum master → human):**\n- Progress reports: what completed, what's in flight, what's blocked\n- Blocker alerts: dependencies stuck, agents failing, rate limits hit\n- Decision requests: ambiguous tasks needing human judgment\n- Stage transition summaries: 'task X moved to review, agent Y picked it up'\n\n**Inbound (human → scrum master):**\n- Priority changes: 'drop everything, focus on X'\n- Task creation: 'add a bug for the login issue'\n- Status queries: 'what's the status of feature Y?'\n- Guidance: 'use approach A not B for auth'\n\n**Key design:**\n- Each project gets its own Matrix room (or thread)\n- The scrum master agent is the only one that talks to humans\n- Other agents (coder, reviewer, ops) report TO the scrum master, not directly to Matrix\n- Reporter refactored to delegate to scrum masters rather than dispatching directly\n- Inbound messages are polled/received and routed to the correct project's scrum master\n\nThis turns Cortex from a silent automation engine into something you can actually talk to per-project.","status":"open","priority":1,"issue_type":"epic","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:19:10.509970488+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:19:10.509970488+10:00"}
{"id":"cortex-a4s.1","title":"Add per-project Matrix room config","description":"Extend cortex.toml and config parser to support per-project Matrix room routing.\n\nCurrent config only has a global [reporter] section with a single channel and agent_id. Need per-project Matrix targeting so each scrum master talks in its own room.\n\nConfig changes:\n```toml\n[projects.hg-website]\nenabled = true\nbeads_dir = \"~/projects/hg-website/.beads\"\nworkspace = \"~/projects/hg-website\"\npriority = 1\nmatrix_room = \"!abc123:matrix.org\"   # NEW: project-specific room\n```\n\nAlso support a default room in [reporter] as fallback:\n```toml\n[reporter]\nchannel = \"matrix\"\nagent_id = \"main\"\ndefault_room = \"!general:matrix.org\"  # fallback if project has no room\n```\n\nChanges to internal/config/config.go:\n- Add MatrixRoom string to Project struct\n- Add DefaultRoom string to Reporter struct\n- Validation: warn (not error) if project has no matrix_room and no default_room\n- Helper: ResolveRoom(project) returns project room or default\n\nAcceptance: Config parses with and without matrix_room, ResolveRoom works, backward compatible","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:20:38.878902601+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:20:38.878902601+10:00","dependencies":[{"issue_id":"cortex-a4s.1","depends_on_id":"cortex-a4s","type":"parent-child","created_at":"2026-02-17T17:20:38.89009374+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-a4s.10","title":"Split scrum master dispatches by tier: Opus for planning, cheap for reporting","description":"The scrum master handles both complex cognitive work (planning, refinement, decisions) and simple mechanical work (status reports, notifications). These should use different tiers.\n\n**Current problem:**\nDetectComplexity() assigns tier based on bead labels/estimate. The scrum master's tier is determined by the bead it's working on, not the function it's performing. A sprint planning pass and a status ping both go through the same tier selection. Wasteful.\n\n**Tier split by scrum master function:**\n\nPremium (Claude Opus):\n- Sprint planning (reviewing full backlog, making prioritization decisions)\n- Backlog refinement (adding acceptance criteria, design notes)\n- Inbound command handling (parsing human intent, deciding actions)\n- Decision requests (identifying ambiguity, framing options)\n\nFast/Balanced (free or cheap models):\n- Daily standup reports (templated, data-driven)\n- Stage transition notifications (mechanical: 'X moved to review')\n- Blocker alerts (templated: 'X is stuck because Y')\n- Status query responses (read beads, summarize)\n- Completion summaries (mechanical: 'X closed, N files changed')\n\n**Implementation:**\n\nAdd a dispatch purpose/function concept:\n\n```go\n// internal/scheduler/purpose.go\ntype DispatchPurpose string\n\nconst (\n    PurposeSprintPlanning  DispatchPurpose = \"sprint_planning\"\n    PurposeRefinement      DispatchPurpose = \"refinement\"\n    PurposeInboundCommand  DispatchPurpose = \"inbound_command\"\n    PurposeDecisionRequest DispatchPurpose = \"decision_request\"\n    PurposeStandup         DispatchPurpose = \"standup\"\n    PurposeNotification    DispatchPurpose = \"notification\"\n    PurposeStatusQuery     DispatchPurpose = \"status_query\"\n)\n\n// TierForPurpose returns the appropriate tier for a dispatch purpose.\nfunc TierForPurpose(purpose DispatchPurpose) string {\n    switch purpose {\n    case PurposeSprintPlanning, PurposeRefinement,\n         PurposeInboundCommand, PurposeDecisionRequest:\n        return \"premium\"\n    case PurposeStandup, PurposeNotification,\n         PurposeStatusQuery:\n        return \"fast\"\n    default:\n        return \"balanced\"\n    }\n}\n```\n\nConfig override (optional, let users tune):\n```toml\n[scrum_tiers]\nsprint_planning = \"premium\"\nrefinement = \"premium\"\ninbound_command = \"premium\"\ndecision_request = \"premium\"\nstandup = \"fast\"\nnotification = \"fast\"\nstatus_query = \"fast\"\n```\n\n**Integration points:**\n- SprintPlanner.RunPlanning() passes PurposeSprintPlanning → tier=premium\n- Reporter/Notifier passes PurposeNotification → tier=fast\n- InboundProcessor.HandleMessage() passes PurposeInboundCommand → tier=premium\n- Standup report passes PurposeStandup → tier=fast\n- TierForPurpose() replaces DetectComplexity() for scrum master dispatches\n- Other roles (coder, reviewer, ops) continue using DetectComplexity() as before\n\n**Provider config:**\nAdd Opus to premium tier in cortex.toml:\n```toml\n[providers.opus]\ntier = \"premium\"\nauthed = true\nmodel = \"claude-opus-4-6\"\n```\n\nAcceptance:\n- Sprint planning and refinement dispatch through premium tier (Opus)\n- Status/notification dispatches use fast tier (free models)\n- Config allows overriding tier per purpose\n- Other roles unaffected\n- Rate limit impact minimized (most scrum master work is cheap)","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:29:51.383490329+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:29:51.383490329+10:00","dependencies":[{"issue_id":"cortex-a4s.10","depends_on_id":"cortex-a4s","type":"parent-child","created_at":"2026-02-17T17:29:51.38850478+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a4s.10","depends_on_id":"cortex-a4s.9","type":"blocks","created_at":"2026-02-17T17:29:57.797438226+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a4s.10","depends_on_id":"cortex-a4s.4","type":"blocks","created_at":"2026-02-17T17:29:57.932871392+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a4s.10","depends_on_id":"cortex-a4s.8","type":"blocks","created_at":"2026-02-17T17:29:58.10315621+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-a4s.11","title":"Implement scrum master sprint review and retrospective","description":"Add a sprint review + retrospective ceremony where the scrum master analyzes what happened, what failed, what was learned, and what to change.\n\n**Current state:**\n- retro.go generates raw stats: dispatch counts, provider failure rates, tier accuracy, misclassification %\n- outcomes.go has velocity, provider stats queries\n- FormatRetroMarkdown() outputs a data table\n- Nobody reasons about the data. It's numbers without narrative.\n\n**What's needed — two related processes:**\n\n### 1. Sprint Review (end of sprint / weekly)\nWhat was planned vs what was delivered.\n\nData fed to scrum master:\n- Beads selected in last sprint planning (from RecordSprintPlanning)\n- Which were completed, which are still open, which failed\n- Completion rate: N/M planned beads done\n- Unplanned work: beads completed that weren't in the sprint plan\n- Scope creep: beads added mid-sprint\n- Velocity trend: this sprint vs last 3 sprints\n\nScrum master (Opus tier) produces:\n- Narrative summary of what shipped\n- Highlight any beads that were planned but not delivered, with why\n- Note unplanned work that displaced planned work\n- Velocity assessment: accelerating, stable, or slowing\n- Sent to Matrix\n\n### 2. Sprint Retrospective (end of sprint / weekly, after review)\nWhat went well, what went wrong, what to change.\n\nData fed to scrum master:\n- Full RetroReport from retro.go (provider stats, tier accuracy)\n- Failed dispatches with details: which beads, which providers, what tier, how many retries\n- Stuck dispatches: what timed out, was escalation effective\n- Tier misclassifications: fast tasks that took premium-level time, premium tasks that were trivial\n- Health events: gateway restarts, zombie cleanups\n- Agent performance: which agents (coder/reviewer/ops) completed fastest, which struggled\n- Rate limit usage: did we hit caps, how close\n\nScrum master (Opus tier) analyzes and produces:\n- **What went well**: patterns in successful dispatches, effective provider/tier combos\n- **What went wrong**: failure patterns, recurring issues, wasted capacity\n- **Learnings**: 'Provider X fails on Go tasks but succeeds on frontend', 'Tier misclassification is high for tasks with no estimate — we should require estimates in sprint planning'\n- **Action items**: concrete changes to make\n  - Config changes: 'deprioritize provider X', 'adjust complexity thresholds'\n  - Process changes: 'require estimates before stage:ready', 'add gate for linting'\n  - Beads to create: 'file a bug for the recurring test flake in project Y'\n- Scrum master can actually EXECUTE simple action items (update config, create beads)\n\n### Implementation:\n\nCreate internal/learner/ceremonies.go:\n\ntype SprintCeremony struct {\n    store      *store.Store\n    dispatcher *dispatch.Dispatcher\n    cfg        *config.Config\n    logger     *slog.Logger\n}\n\nfunc (sc *SprintCeremony) RunReview(ctx, project):\n1. Gather sprint review data (planned vs delivered)\n2. Build ProjectContext\n3. Dispatch to scrum master with review prompt (premium tier)\n4. Scrum master outputs narrative to Matrix\n\nfunc (sc *SprintCeremony) RunRetro(ctx, project):\n1. Generate RetroReport via GenerateWeeklyRetro()\n2. Query failed/stuck dispatches with details\n3. Get health events for the sprint period\n4. Build comprehensive analysis prompt with all data\n5. Dispatch to scrum master with retro prompt (premium tier)\n6. Scrum master outputs learnings + action items to Matrix\n\n### Scheduling:\nConfig:\n```toml\n[projects.hg-website]\nsprint_review_day = \"Friday\"\nsprint_review_time = \"16:00\"\nsprint_retro_day = \"Friday\"     # runs after review\nsprint_retro_time = \"17:00\"\n```\n\nOr derive from existing weekly_retro_day in [reporter].\n\n### Store additions:\n- GetFailedDispatchDetails(project, window) → []FailedDispatch with bead title, provider, tier, error context, retry count\n- GetStuckDispatchDetails(project, window) → []StuckDispatch with timeout duration, escalation history\n- GetAgentPerformance(project, window) → map[agent]AgentStats (completed, failed, avg duration)\n\n### Prompt templates:\nAdd 'sprint_review' and 'sprint_retro' to stageInstructions in prompt.go. These are the longest, most detailed prompts — they give the scrum master all the raw data and ask it to reason about patterns.\n\n### Tier:\nBoth ceremonies use premium tier (Opus) — this is analytical reasoning work.\n\n### Relationship to existing code:\n- retro.go: keep as data layer, ceremonies.go calls it\n- outcomes.go: keep as data layer, extend with new queries\n- reporter.go: ceremonies dispatch through scrum master, not through reporter directly\n\nAcceptance:\n- Sprint review compares planned vs delivered, produces narrative\n- Sprint retro analyzes failures/learnings, produces action items\n- Both dispatched through scrum master at premium tier\n- Data comes from existing retro.go + new detail queries\n- Sent to Matrix via scrum master agent\n- Scrum master can create follow-up beads from action items\n- Scheduled weekly, configurable day/time","status":"open","priority":1,"issue_type":"feature","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:32:27.739648447+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:32:27.739648447+10:00","dependencies":[{"issue_id":"cortex-a4s.11","depends_on_id":"cortex-a4s","type":"parent-child","created_at":"2026-02-17T17:32:27.745043106+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a4s.11","depends_on_id":"cortex-a4s.2","type":"blocks","created_at":"2026-02-17T17:32:37.285776045+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a4s.11","depends_on_id":"cortex-a4s.3","type":"blocks","created_at":"2026-02-17T17:32:37.519704868+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a4s.11","depends_on_id":"cortex-a4s.9","type":"blocks","created_at":"2026-02-17T17:32:37.698330207+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a4s.11","depends_on_id":"cortex-a4s.7","type":"blocks","created_at":"2026-02-17T17:32:37.832795531+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-a4s.2","title":"Give scrum master project state context","description":"Build a project state summarizer that gives the scrum master rich context about its project before it communicates.\n\nCurrently when a scrum master agent is dispatched, it only sees the single bead it's refining. To be a useful point of contact, it needs the full picture.\n\nCreate internal/scheduler/context.go with:\n\ntype ProjectContext struct {\n    Project       string\n    OpenBeads     int\n    InProgress    int\n    Blocked       int\n    CompletedToday int\n    FailedToday   int\n    RunningAgents []RunningAgent  // currently dispatched\n    RecentCompletions []string    // last 5 completed bead titles\n    BlockerSummary    []string    // what's blocked and why\n    Velocity          float64     // beads/day rolling 7d\n}\n\ntype RunningAgent struct {\n    Agent    string\n    BeadID   string\n    BeadTitle string\n    Role     string\n    Duration time.Duration\n}\n\nfunc BuildProjectContext(store, project) ProjectContext:\n- Query store for dispatch stats\n- Query beads for open/blocked/in-progress counts\n- Calculate velocity from GetProjectVelocity\n- List running dispatches with durations\n\nfunc FormatContextForPrompt(ctx ProjectContext) string:\n- Render as markdown section that gets prepended to scrum master prompts\n- Concise but complete: '3 open, 1 blocked (X depends on Y), 2 agents running'\n\nAcceptance: Context builds from store data, formats cleanly, tested","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:20:50.868998306+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:20:50.868998306+10:00","dependencies":[{"issue_id":"cortex-a4s.2","depends_on_id":"cortex-a4s","type":"parent-child","created_at":"2026-02-17T17:20:50.871928723+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-a4s.3","title":"Refactor Reporter to route through scrum master agents","description":"Change the Reporter to dispatch messages through each project's scrum master agent instead of the generic 'main' agent.\n\nCurrent flow (internal/learner/reporter.go):\n  Reporter.dispatchMessage() → dispatcher.Dispatch(cfg.AgentID='main', message)\n\nNew flow:\n  Reporter.SendProjectDigest(project) → dispatcher.Dispatch(project+'-scrum', message)\n  Reporter.SendProjectAlert(project, type, msg) → dispatcher.Dispatch(project+'-scrum', message)\n\nKey changes:\n- SendDigest becomes SendDigests (iterates projects, sends per-project digest)\n- Each digest goes through that project's scrum master agent\n- The scrum master agent's system prompt (ROLE.md) already positions it as the communicator\n- Include ProjectContext in the digest prompt so scrum master has full picture\n- The scrum master then formats and sends to Matrix (its agent config points at the project's room)\n\nFallback: if project has no scrum master agent, fall back to generic 'main' agent\n\nRemove the old single-message-blast pattern. Each project gets its own tailored communication.\n\nAcceptance: Digests route through scrum master, per-project context included, fallback works","status":"open","priority":1,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:20:55.978000565+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:20:55.978000565+10:00","dependencies":[{"issue_id":"cortex-a4s.3","depends_on_id":"cortex-a4s","type":"parent-child","created_at":"2026-02-17T17:20:55.980979041+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a4s.3","depends_on_id":"cortex-a4s.1","type":"blocks","created_at":"2026-02-17T17:21:57.093685141+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a4s.3","depends_on_id":"cortex-a4s.2","type":"blocks","created_at":"2026-02-17T17:21:57.290914978+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-a4s.4","title":"Implement scrum master outbound notifications","description":"Add event-driven outbound notifications from the scrum master to Matrix, beyond just daily digests.\n\nNotification types (internal/scheduler/notify.go or similar):\n\n1. **Blocker Alert**: When a bead becomes blocked or an agent fails\n   - Trigger: dispatch fails, stuck timeout hit, rate limit exhausted\n   - Message: 'Task X is blocked: agent failed after 30m, escalating to premium tier'\n\n2. **Stage Transition**: When a bead moves between stages\n   - Trigger: stage label changes detected during bead discovery\n   - Message: 'Task X moved to review (was: coding). Agent hg-website-reviewer picking it up next tick.'\n\n3. **Decision Request**: When scrum master identifies ambiguity during refinement\n   - Trigger: scrum master's refinement output contains a decision flag\n   - Message: 'Task X needs clarification: should we use REST or GraphQL for the new endpoint?'\n\n4. **Completion Summary**: When a bead is closed\n   - Trigger: bead status changes to closed\n   - Message: 'Task X completed by hg-website-coder. 3 files changed, tests passing.'\n\n5. **Capacity Warning**: When rate limits approach headroom\n   - Trigger: WeeklyUsagePct \u003e headroom threshold\n   - Message: 'Rate limit at 85%. 30 dispatches remaining this week. Prioritize carefully.'\n\nImplementation:\n- Create a Notifier that the scheduler calls at appropriate points in RunTick\n- Notifier routes through the project's scrum master agent\n- Dedup logic (don't spam same alert within 1h, already exists in Reporter)\n- Notification preferences per project (optional, can be added later)\n\nAcceptance: All 5 notification types fire at correct triggers, routed through scrum master, deduped","status":"open","priority":1,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:21:04.804924868+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:21:04.804924868+10:00","dependencies":[{"issue_id":"cortex-a4s.4","depends_on_id":"cortex-a4s","type":"parent-child","created_at":"2026-02-17T17:21:04.810369436+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a4s.4","depends_on_id":"cortex-a4s.2","type":"blocks","created_at":"2026-02-17T17:22:01.301398933+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a4s.4","depends_on_id":"cortex-a4s.3","type":"blocks","created_at":"2026-02-17T17:22:01.47223537+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-a4s.5","title":"Implement Matrix inbound message polling","description":"Add the ability for Cortex to receive inbound messages from humans via Matrix and route them to the correct project's scrum master.\n\nThis is the hardest piece — making communication bidirectional.\n\nCreate internal/matrix/poller.go:\n\nApproach: Poll Matrix room(s) for new messages using the Matrix client-server API.\n\ntype Poller struct {\n    homeserver string\n    token      string\n    rooms      map[string]string // room_id → project name\n    since      string           // sync token for incremental polling\n    interval   time.Duration\n    handler    InboundHandler\n}\n\ntype InboundMessage struct {\n    Project   string\n    Room      string\n    Sender    string\n    Body      string\n    Timestamp time.Time\n    EventID   string\n}\n\ntype InboundHandler interface {\n    HandleMessage(ctx context.Context, msg InboundMessage) error\n}\n\nFlow:\n1. Poller runs on interval (e.g. 30s)\n2. Calls Matrix /sync endpoint with since token\n3. Filters for m.room.message events in tracked rooms\n4. Ignores messages from our own bot user\n5. Maps room → project\n6. Calls handler.HandleMessage() for each new message\n\nConfig additions to [reporter] or new [matrix] section:\n```toml\n[matrix]\nhomeserver = \"https://matrix.org\"\ntoken_env = \"CORTEX_MATRIX_TOKEN\"  # read from env var, never in config\npoll_interval = \"30s\"\nbot_user = \"@cortex-bot:matrix.org\"\n```\n\nSecurity: token read from env var only. Never stored in config file.\n\nAcceptance: Poller connects to Matrix, receives messages, routes to correct project, handles reconnection","status":"open","priority":1,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:21:14.181085879+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:21:14.181085879+10:00","dependencies":[{"issue_id":"cortex-a4s.5","depends_on_id":"cortex-a4s","type":"parent-child","created_at":"2026-02-17T17:21:14.187008568+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a4s.5","depends_on_id":"cortex-a4s.1","type":"blocks","created_at":"2026-02-17T17:22:04.609786866+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-a4s.6","title":"Implement scrum master inbound command handling","description":"When the scrum master receives an inbound human message via Matrix, it needs to understand and act on it.\n\nCreate internal/scheduler/inbound.go:\n\ntype InboundProcessor struct {\n    store      *store.Store\n    dispatcher *dispatch.Dispatcher\n    projects   map[string]config.Project\n}\n\nfunc (p *InboundProcessor) HandleMessage(ctx, msg InboundMessage) error:\n1. Dispatch to the project's scrum master agent with:\n   - The human's message\n   - Current ProjectContext\n   - Instructions to parse intent and take action\n2. The scrum master agent determines what to do:\n   - **Status query** → respond with project state summary\n   - **Priority change** → run bd update to reprioritize\n   - **Task creation** → run bd create with details\n   - **Guidance** → update relevant bead's design notes\n   - **Other** → acknowledge and note for next standup\n3. Scrum master's response goes back to the Matrix room\n\nThe scrum master agent handles the NLU — we don't need to parse commands ourselves. The agent's ROLE.md should be updated to include:\n- 'When you receive a human message, determine the intent and take the appropriate action'\n- 'Always respond in the Matrix room with what you did'\n- 'For status queries, use bd list and bd show to gather current state'\n\nUpdate ROLE.md in internal/team/team.go to add communication responsibilities.\n\nAcceptance: Human messages dispatched to scrum master, scrum master responds with actions, response sent back to Matrix","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:21:24.490363129+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:21:24.490363129+10:00","dependencies":[{"issue_id":"cortex-a4s.6","depends_on_id":"cortex-a4s","type":"parent-child","created_at":"2026-02-17T17:21:24.501960084+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a4s.6","depends_on_id":"cortex-a4s.5","type":"blocks","created_at":"2026-02-17T17:22:08.708436386+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a4s.6","depends_on_id":"cortex-a4s.2","type":"blocks","created_at":"2026-02-17T17:22:09.089043739+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a4s.6","depends_on_id":"cortex-a4s.7","type":"blocks","created_at":"2026-02-17T17:22:09.293367704+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-a4s.7","title":"Update scrum master ROLE.md for communication responsibilities","description":"Update the scrum master agent's role description in internal/team/team.go to reflect its new position as the project's point of contact.\n\nCurrent ROLE.md focuses only on task refinement. Expand to cover:\n\n```markdown\n# Scrum Master Agent\n\nYou are the scrum master and primary point of contact for this project.\n\n## Communication (Primary)\n- You are the ONLY agent that communicates with humans\n- Report progress, blockers, and decisions via Matrix\n- When you receive a human message, determine intent and act:\n  - Status queries: gather state with bd list/show, summarize\n  - Priority changes: reprioritize with bd update\n  - Task creation: create beads with bd create\n  - Guidance: update design notes on relevant beads\n  - Always confirm what you did\n\n## Daily Standup\n- Summarize: what completed yesterday, what's in progress, any blockers\n- Flag beads that have been in_progress for \u003e24h\n- Highlight rate limit status if above 70%\n\n## Task Refinement\n- Review descriptions for clarity and completeness\n- Add or improve acceptance criteria\n- Break large tasks into sub-tasks\n- Estimate effort when missing\n\n## Stage Workflow\n- You receive tasks at stage:backlog\n- When refinement is complete, transition to stage:planning\n- Always unassign yourself after transitioning\n```\n\nAlso update EnsureTeam() to re-write ROLE.md if it detects the old version (or add a version marker).\n\nAcceptance: New ROLE.md covers communication, standup, and refinement. Agent behaves as point of contact.","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:21:36.630347088+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:21:36.630347088+10:00","dependencies":[{"issue_id":"cortex-a4s.7","depends_on_id":"cortex-a4s","type":"parent-child","created_at":"2026-02-17T17:21:36.639118512+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-a4s.8","title":"Implement scrum master daily standup report","description":"Replace the generic daily digest with a scrum-master-authored standup report per project.\n\nCurrent digest (Reporter.SendDigest) is a simple template:\n  '## Daily Cortex Digest — {date}\n   - project: N beads completed today\n   - Health: N events'\n\nNew standup (dispatched through scrum master agent):\nThe scrum master receives ProjectContext and produces a standup-style report:\n\n**Yesterday:**\n- Completed: list of closed beads with brief outcomes\n- Failed: any beads that failed with reasons\n\n**Today:**\n- In Progress: what's currently being worked, by which agent\n- Ready: what's unblocked and queued for dispatch\n- Blocked: what's stuck and on what\n\n**Risks:**\n- Rate limit status (usage/cap)\n- Stuck dispatches or repeated failures\n- Beads in_progress for \u003e24h\n\nThe scrum master formats this conversationally, not as raw data. It should feel like a team standup message in a chat room.\n\nSchedule: runs at daily_digest_time from config (default 09:00).\nReplaces Reporter.SendDigest() calls — the standup IS the digest.\n\nAcceptance: Standup generates per-project, routed through scrum master, includes all sections, conversational tone","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:21:48.097683349+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:21:48.097683349+10:00","dependencies":[{"issue_id":"cortex-a4s.8","depends_on_id":"cortex-a4s","type":"parent-child","created_at":"2026-02-17T17:21:48.101256464+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a4s.8","depends_on_id":"cortex-a4s.3","type":"blocks","created_at":"2026-02-17T17:22:13.485440432+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a4s.8","depends_on_id":"cortex-a4s.2","type":"blocks","created_at":"2026-02-17T17:22:13.651877467+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-a4s.9","title":"Implement scrum master sprint planning function","description":"Add a sprint planning mode where the scrum master reviews the entire backlog holistically, refines beads in bulk, and selects a sprint's worth of work.\n\n**Current problem:**\nThe scrum master is dispatched per-bead (one stage:backlog bead → one dispatch). It never sees the full picture. It can't prioritize across beads, spot duplicates, identify missing work, or decide what goes into the next sprint. It's a bead-refiner, not a planner.\n\n**Sprint planning function:**\n\nTrigger: scheduled (e.g. weekly, configurable) OR when backlog exceeds threshold (e.g. \u003e5 unrefined beads) OR manual trigger via Matrix.\n\nConfig:\n```toml\n[projects.hg-website]\nsprint_planning_day = \"Monday\"        # weekly trigger\nsprint_planning_time = \"08:00\"\nsprint_capacity = 10                   # max beads per sprint\nbacklog_threshold = 5                  # auto-trigger if unrefined backlog exceeds this\n```\n\nCreate internal/scheduler/sprint.go:\n\ntype SprintPlanner struct {\n    store      *store.Store\n    dispatcher *dispatch.Dispatcher\n    cfg        *config.Config\n    logger     *slog.Logger\n}\n\nfunc (sp *SprintPlanner) RunPlanning(ctx, project, projectCfg):\n\n1. **Gather backlog**: List all beads that are open + have no stage label or stage:backlog\n2. **Build context**: Include already-in-progress work, recently closed beads, dependency graph\n3. **Dispatch scrum master with full backlog**:\n   - Send ALL backlog beads to the scrum master in a single dispatch (not one-by-one)\n   - Prompt includes every backlog bead's title, description, current priority, estimate, labels\n   - Also includes the dependency graph so scrum master can see what unblocks what\n4. **Scrum master instructions** (sprint planning prompt template):\n   - Review each backlog bead for clarity and completeness\n   - Add acceptance criteria where missing (bd update \u003cid\u003e --acceptance=\"...\")\n   - Add design notes with implementation approach (bd update \u003cid\u003e --design=\"...\")\n   - Set or adjust estimates (bd update \u003cid\u003e --estimate=\u003cminutes\u003e)\n   - Set or adjust priority based on business value + dependencies\n   - Break down any bead estimated \u003e120min into sub-tasks\n   - Identify and flag duplicate or overlapping beads\n   - Select top N beads (up to sprint_capacity) and transition them: bd update \u003cid\u003e --labels stage:planning\n   - Leave remaining beads in backlog with notes on why deferred\n   - Output a sprint plan summary at the end\n\n5. **Sprint plan summary** (sent to Matrix via scrum master):\n   - What's in the sprint (selected beads with priorities)\n   - What was deferred and why\n   - Any blockers or risks identified\n   - Estimated sprint capacity usage\n\n**New prompt template** in internal/scheduler/prompt.go:\nAdd a 'sprint_planning' key to stageInstructions that includes the full backlog context and planning instructions above.\n\n**Scheduler integration**:\n- Add a sprint planning check to RunTick or as a separate goroutine\n- Check: is it sprint_planning_day + sprint_planning_time? → trigger\n- Check: count of stage:backlog beads \u003e backlog_threshold? → trigger\n- Dedup: don't re-trigger if planning ran within last 24h (track in store)\n\n**Store additions**:\n- RecordSprintPlanning(project, beadsSelected, beadsDeferred, timestamp)\n- GetLastSprintPlanning(project) → timestamp (for dedup)\n\nAcceptance:\n- Sprint planning dispatches scrum master with full backlog context\n- Scrum master refines, estimates, and selects beads in one pass\n- Sprint plan summary sent to Matrix\n- Triggers work (scheduled + threshold + manual)\n- Config is backward compatible (no sprint planning = old behavior)","status":"open","priority":1,"issue_type":"feature","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:26:38.982883997+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:26:38.982883997+10:00","dependencies":[{"issue_id":"cortex-a4s.9","depends_on_id":"cortex-a4s","type":"parent-child","created_at":"2026-02-17T17:26:39.003463728+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a4s.9","depends_on_id":"cortex-a4s.2","type":"blocks","created_at":"2026-02-17T17:26:43.470607057+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a4s.9","depends_on_id":"cortex-a4s.7","type":"blocks","created_at":"2026-02-17T17:26:43.657625009+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-a6p","title":"Cost tracking and budget management","description":"Rate limits count dispatches but not dollars. Claude Opus costs 100x what Cerebras does. A 'fast' dispatch and a 'premium' dispatch look identical to Cortex's accounting. No way to answer 'how much did this sprint cost?' or 'which project is burning money?'\n\nKey deliverables:\n- Cost field on provider config (cost per 1K input/output tokens)\n- Token usage recording per dispatch\n- Cost-per-dispatch, per-bead, per-project, per-sprint analytics\n- Cost budgeting: max $/week per project\n- Cost alerts when approaching budget\n- Cost data feeds into retro analysis","status":"open","priority":1,"issue_type":"epic","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:57:33.035311012+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:57:33.035311012+10:00"}
{"id":"cortex-a6p.1","title":"Add cost fields to provider config and dispatch recording","description":"Add cost-per-token pricing to provider definitions and record token usage per dispatch.\n\nConfig changes:\n```toml\n[providers.claude-opus]\ntier = \"premium\"\nauthed = true\nmodel = \"claude-opus-4-6\"\ncost_input_per_mtok = 15.00    # $ per million input tokens\ncost_output_per_mtok = 75.00   # $ per million output tokens\n```\n\nAdd to internal/config/config.go Provider struct:\n- CostInputPerMtok float64\n- CostOutputPerMtok float64\n\nDB schema changes (internal/store/store.go):\n- Add columns to dispatches: input_tokens INT, output_tokens INT, cost_usd REAL\n- Add columns to provider_usage: input_tokens INT, output_tokens INT\n\nNew methods:\n- RecordDispatchCost(dispatchID, inputTokens, outputTokens, costUSD)\n- GetDispatchCost(dispatchID) (inputTokens, outputTokens, costUSD)\n\nToken extraction: parse from agent output (openclaw likely reports token usage in output or exit summary). If not available, estimate from prompt length (input) and output capture length.\n\nAcceptance: Cost fields in config, token/cost recorded per dispatch, backward compatible if cost fields missing","status":"open","priority":1,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:58:57.600063644+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:58:57.600063644+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-a6p.1","depends_on_id":"cortex-a6p","type":"parent-child","created_at":"2026-02-17T17:58:57.604065002+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-a6p.2","title":"Implement cost analytics queries","description":"Build cost aggregation queries for per-bead, per-project, per-sprint, and per-provider cost analysis.\n\nCreate internal/learner/costs.go:\n```go\ntype CostSummary struct {\n    TotalCostUSD     float64\n    TotalInputTokens int64\n    TotalOutputTokens int64\n    DispatchCount    int\n    AvgCostPerDispatch float64\n    AvgCostPerBead   float64\n}\n\n// GetProjectCost returns cost for a project over a time window\nfunc GetProjectCost(store, project string, window time.Duration) (*CostSummary, error)\n\n// GetSprintCost returns cost for all projects in a sprint\nfunc GetSprintCost(store, sprintStart, sprintEnd time.Time) (map[string]*CostSummary, error)\n\n// GetProviderCost returns cost breakdown by provider\nfunc GetProviderCost(store, window time.Duration) (map[string]*CostSummary, error)\n\n// GetBeadCost returns total cost for a specific bead (may span multiple dispatches/retries)\nfunc GetBeadCost(store, beadID string) (*CostSummary, error)\n\n// GetCostTrend returns daily cost for the last N days\nfunc GetCostTrend(store, days int) ([]DailyCost, error)\n```\n\nAcceptance: All queries return correct aggregations, tested with sample data","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:59:03.031411611+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:59:03.031411611+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-a6p.2","depends_on_id":"cortex-a6p","type":"parent-child","created_at":"2026-02-17T17:59:03.035485735+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a6p.2","depends_on_id":"cortex-a6p.1","type":"blocks","created_at":"2026-02-17T17:59:19.05714194+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-a6p.3","title":"Add cost budgeting and alerts","description":"Set cost budgets per project and alert when approaching limits.\n\nConfig:\n```toml\n[projects.hg-website]\ncost_budget_weekly = 50.00    # max $50/week\ncost_budget_monthly = 150.00  # max $150/month\n```\n\nCreate internal/dispatch/costlimit.go:\n```go\n// CanAffordDispatch checks if project has budget remaining\nfunc CanAffordDispatch(store, project string, estimatedCost float64) (bool, float64 remaining)\n\n// EstimateDispatchCost estimates cost based on provider pricing and average token usage\nfunc EstimateDispatchCost(provider config.Provider, avgTokens int) float64\n```\n\nIntegration:\n- Scheduler checks CanAffordDispatch before dispatching (alongside rate limits)\n- If budget exhausted, skip project this tick (like rate limiting)\n- Alert via reporter when project hits 80% of budget\n- Include in API /status endpoint\n\nAcceptance: Budget enforced, dispatches blocked when over budget, alerts fire at threshold","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:59:08.28014723+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:59:08.28014723+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-a6p.3","depends_on_id":"cortex-a6p","type":"parent-child","created_at":"2026-02-17T17:59:08.343898102+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a6p.3","depends_on_id":"cortex-a6p.1","type":"blocks","created_at":"2026-02-17T17:59:22.006029004+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-a6p.4","title":"Add cost metrics to API and retro","description":"Surface cost data in API endpoints and include in retrospective analysis.\n\nAPI additions:\n- GET /costs — overall cost summary (today, this week, this month)\n- GET /costs/{project} — per-project cost breakdown\n- GET /metrics — add cortex_cost_usd_total counter, cortex_cost_usd_weekly gauge\n\nRetro additions:\n- Include cost data in RetroReport: total spend, cost per bead, cost by tier\n- Cost efficiency: cost per completed bead vs cost per failed bead\n- Provider cost-effectiveness: quality score / cost ratio\n- Feed into scrum master and chief SM retro prompts\n\nAcceptance: Cost visible in API, prometheus metrics, and retro reports","status":"open","priority":3,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:59:15.549332439+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:59:15.549332439+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-a6p.4","depends_on_id":"cortex-a6p","type":"parent-child","created_at":"2026-02-17T17:59:15.552183403+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a6p.4","depends_on_id":"cortex-a6p.2","type":"blocks","created_at":"2026-02-17T17:59:24.968311549+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-a6p.4","depends_on_id":"cortex-a6p.3","type":"blocks","created_at":"2026-02-17T17:59:27.893634713+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-anx","title":"Update scheduler to route dispatches by tier and retry count","description":"Update internal/scheduler/scheduler.go to select backend based on dispatch.routing config:\n\n- Fast tier → headless backend\n- Balanced tier, first attempt → headless backend  \n- Balanced tier, retry → tmux backend\n- Premium tier → tmux backend\n- Any retry (regardless of tier) → tmux backend (retry_backend config)\n- Comms/reports → openclaw backend\n\nScheduler holds map[string]Backend initialized from config. pickBackend(tier, retryCount) returns the right one.\n\nUpdate RunTick to:\n1. Resolve backend from tier + retry count\n2. Build DispatchOpts from CLI config + provider config\n3. Call backend.Dispatch()\n4. Store Handle (with backend type, log_path, session_name, branch) in dispatches table\n\nUpdate checkRunningDispatches to call backend.Status() based on stored backend type.\n\nAcceptance: fast tasks use headless, premium use tmux, retries promote to tmux. Mixed backends tracked correctly.","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:30.287975591+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:30.287975591+10:00","dependencies":[{"issue_id":"cortex-anx","depends_on_id":"cortex-hgz","type":"blocks","created_at":"2026-02-17T18:01:30.027269698+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-anx","depends_on_id":"cortex-v2h","type":"blocks","created_at":"2026-02-17T18:01:30.346434221+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-anx","depends_on_id":"cortex-ejd","type":"blocks","created_at":"2026-02-17T18:01:30.602060206+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-anx","depends_on_id":"cortex-x83","type":"blocks","created_at":"2026-02-17T18:01:30.780080141+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-c6c","title":"Update stuck detection to use tier-aware timeouts","description":"Update internal/health/stuck.go to use per-tier timeouts from dispatch.timeouts config instead of global stuck_timeout.\n\n- Fast: 15m (was 30m globally)\n- Balanced: 45m\n- Premium: 120m\n\nGetStuckDispatches query needs to join on tier column and compare against tier-specific timeout.\nStuck kill should use backend.Kill() instead of direct KillProcess().\n\nAcceptance: fast tasks killed at 15m, premium tasks allowed to run 120m. Backend-aware kill (tmux vs PID).","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:48.458342856+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:48.458342856+10:00"}
{"id":"cortex-ceg","title":"Plan pluggable dispatch: headless CLI vs tmux vs openclaw by task complexity","description":"Plan the dispatcher abstraction to support multiple backends based on task characteristics.\n\n## Context\n- Current dispatch is tightly coupled to openclaw agent CLI (~5 lines in dispatch.go)\n- OpenClaw gateway serves comms and planning, not just agent dispatch — that value must be preserved or replaced\n- Headless CLIs (claude, codex, kimi, kilocode) can handle coding tasks directly without a gateway\n- tmux gives observability and session persistence for longer/complex work\n\n## Key Design Questions\n\n### 1. Task routing by complexity/length\n- **Fast tier (≤30min, trivial/chore)**: headless CLI is ideal — fire and forget, low overhead\n- **Balanced tier (31-90min)**: headless CLI or tmux? At what duration does observability matter?\n- **Premium tier (\u003e90min, complex/architecture)**: tmux likely better — attach to watch, survives crashes, can interact if stuck\n- Should routing be tier-based, estimate-based, or label-based?\n\n### 2. When tmux vs headless\n- tmux adds: observability (attach to watch), crash resilience (session persists), ability to interact\n- tmux costs: session management complexity, cleanup of dead sessions, port/name collisions\n- headless adds: simplicity, easy PID tracking (already implemented), lower overhead\n- Decision: what's the threshold? 60min? 'complex' label? premium tier only?\n\n### 3. OpenClaw gateway role\n- Gateway currently handles comms (Matrix?) and planning/coordination between agents\n- If we move coding dispatch to headless CLIs, gateway still needed for:\n  - Inter-agent communication\n  - Task planning and decomposition\n  - Status reporting\n  - Any shared context/memory between agents\n- Need to map which gateway functions are essential vs replaceable\n\n### 4. Pluggable dispatcher interface\n- Abstract dispatch behind a Go interface: Dispatch(ctx, prompt, workDir, opts) -\u003e (handle, err)\n- Backends: headless-cli, tmux, openclaw (keep as option)\n- Config in cortex.toml per-provider or per-tier\n- Process tracking: PID for headless, session name for tmux, PID for openclaw\n\n### 5. Provider mapping\n- Which headless CLIs map to which providers?\n  - claude CLI -\u003e claude-max20 (and free tier via different model flag)\n  - codex CLI -\u003e openai-pro\n  - kimi CLI -\u003e kimi\n  - kilocode -\u003e ?\n- How do thinking levels translate per CLI?\n\n## Deliverable\nArchitecture decision doc + implementation plan for the dispatcher refactor.","design":"## Architecture Decision: Pluggable Dispatch\n\n### Dispatch Backends\n\nThree backends, selected by tier + retry state:\n\n| Backend | When | Implementation |\n|---|---|---|\n| HeadlessCLI | Fast tier, balanced tier (first attempt) | exec.Command + stdout/stderr to log file |\n| Tmux | Premium tier, any retry, 'interactive' label | tmux new-session with remain-on-exit, capture-pane for output |\n| OpenClaw | Comms/reporting only | Existing dispatcher, unchanged |\n\n### Dispatch Routing\n\n```\nFast tier         → always headless\nBalanced tier     → headless on first attempt, tmux on retry\nPremium tier      → always tmux\nAny retry         → tmux (regardless of original tier)\nComms/reports     → openclaw agent (unchanged)\n```\n\n### Provider-to-CLI Mapping\n\n| Tier | CLI | Model | Cost |\n|---|---|---|---|\n| Fast | kilo run --auto | Free gateway (MiniMax, GLM, Kimi K2.5) | Free |\n| Fast | aider --message --yes | Free OpenRouter (Qwen3, DeepSeek R1) | Free |\n| Fast | codex -q | GPT 5.3-spark | API/sub |\n| Balanced | claude -p | Claude Sonnet (Max) | Sub |\n| Balanced | codex -q | GPT 5.3-codex | API/sub |\n| Premium | claude -p | Claude Opus (Max) | Sub |\n| Premium | codex -q | GPT 5.3-codex | API/sub |\n| Premium | kimi | Moonshot | API key |\n| Comms | openclaw agent | Gateway | — |\n\nTest kilo vs aider on fast tier — let learner/retro compare over time.\n\n### Output Capture\n\nAlways capture, all tiers:\n- Headless: redirect stdout/stderr to per-dispatch log file\n- Tmux: capture-pane -p -S - after completion\n- Store path in dispatches table, learner uses for failure analysis\n- Log retention: configurable (default 30 days), old logs pruned on tick\n\n### Prompt Delivery (per CLI)\n\nDifferent CLIs accept prompts differently. Config specifies mode per CLI:\n- `argument`: prompt passed as CLI argument (most CLIs)\n- `stdin`: prompt piped via stdin\n- `tempfile`: prompt written to temp file, path passed as argument\n\nAll modes must handle shell escaping. Tempfile is safest for large prompts.\n\n```toml\n[dispatch.cli.claude]\ncmd = 'claude'\nprompt_mode = 'argument'    # claude -p 'prompt here'\nargs = ['-p', '{prompt}']\nmodel_flag = '--model'\napproval_flags = ['--dangerously-skip-permissions']\n\n[dispatch.cli.codex]\ncmd = 'codex'\nprompt_mode = 'argument'\nargs = ['-q', '{prompt}']\nmodel_flag = '--model'\napproval_flags = ['--auto-approve']\n\n[dispatch.cli.kilo]\ncmd = 'kilo'\nprompt_mode = 'argument'\nargs = ['run', '--auto', '{prompt}']\nmodel_flag = '--model'\napproval_flags = []          # uses kilocode.json permission config\n\n[dispatch.cli.aider]\ncmd = 'aider'\nprompt_mode = 'argument'\nargs = ['--message', '{prompt}', '--yes', '--no-git']\nmodel_flag = '--model'\napproval_flags = ['--yes']\n\n[dispatch.cli.kimi]\ncmd = 'kimi'\nprompt_mode = 'argument'\nargs = ['--print', '{prompt}']\nmodel_flag = ''\napproval_flags = []\n```\n\n### Auto-Approval / Permissions\n\nEach CLI needs autonomous operation flags to prevent hanging on approval prompts:\n- claude: --dangerously-skip-permissions (or granular --allowedTools)\n- codex: --auto-approve or equivalent\n- kilo: permission config in kilocode.json (allow all tools)\n- aider: --yes (auto-confirm all changes)\n- kimi: --print mode is non-interactive by default\n\nApproval flags are part of CLI config, always appended to dispatch command.\nIf a dispatch hangs (no output progress for 5min), treat as stuck.\n\n### Tier-Aware Timeouts\n\nGlobal stuck_timeout replaced with per-tier values:\n\n```toml\n[dispatch.timeouts]\nfast = '15m'\nbalanced = '45m'\npremium = '120m'\n```\n\nFast tasks stuck at 15min are clearly broken. Premium tasks may legitimately run 90min+.\nStuck detection uses tier of the dispatch, not global config.\n\n### Concurrent Dispatch \u0026 Git Isolation\n\nmax_per_tick=3 means parallel dispatches. Same-project conflicts handled by branch isolation:\n\n1. Before dispatch, create branch: git checkout -b ctx/{bead-id} from main\n2. Agent works on its branch\n3. On completion, cortex merges branch to main (or flags conflict for retry)\n4. On failure/stuck, branch is abandoned (cleaned up after retention period)\n\nBranch naming: ctx/{bead-id} (e.g. ctx/cortex-a1b)\nCleanup: branches older than 7 days with no activity pruned on health tick.\n\nAlternative: limit to 1 concurrent dispatch per project (simpler, less throughput).\nDecision: start with branch isolation, fall back to serial if merge conflicts are frequent.\n\n### CLI Fallback Within Tier\n\nIf primary CLI fails (not found, auth error, crash on startup), try next CLI in tier before tier downgrade:\n\n```\nbalanced tier: claude → codex → (tier downgrade to fast)\npremium tier: claude → codex → kimi → (tier downgrade to balanced)\nfast tier: kilo → aider → codex/spark → (tier upgrade to balanced)\n```\n\nCLI failure detected by: non-zero exit within 10s of start (distinguishes 'CLI broken' from 'task failed after working').\nDistinct from tier downgrade (which is rate-limit driven).\n\n### Model Selection\n\nEach provider maps to a CLI + model. Model passed via CLI-specific flag:\n\n```toml\n[providers.claude-max20]\ntier = 'balanced'\nauthed = true\ncli = 'claude'\nmodel = 'sonnet'\n\n[providers.openai-codex]\ntier = 'premium'\nauthed = true\ncli = 'codex'\nmodel = 'gpt-5.3-codex'\n\n[providers.openai-spark]\ntier = 'fast'\nauthed = true\ncli = 'codex'\nmodel = 'gpt-5.3-spark'\n\n[providers.kilo-free]\ntier = 'fast'\nauthed = false\ncli = 'kilo'\nmodel = 'minimax/m2.1'\n\n[providers.aider-free]\ntier = 'fast'\nauthed = false\ncli = 'aider'\nmodel = 'openrouter/qwen3-coder'\n```\n\nDispatch builds command: {cli} {args with prompt} {model_flag} {model} {approval_flags}\n\n### Health Monitoring (Extended)\n\nBeyond gateway health, monitor dispatch infrastructure:\n\n1. Gateway service (existing): systemctl check + auto-restart\n2. tmux server: `tmux info` on health tick, restart if dead\n3. CLI availability: `which {cli}` for each configured CLI on startup + hourly\n4. Auth validity: dry-run or version command per CLI on startup\n   - claude --version, codex --version, kilo --version\n   - Log warning if CLI missing, error if all CLIs in a tier unavailable\n5. Branch cleanup: prune ctx/* branches older than 7 days\n\nHealth events table extended with event types:\n- cli_missing, cli_auth_failed, tmux_server_down, branch_cleanup\n\n### Go Interface\n\n```go\ntype Backend interface {\n    Dispatch(ctx context.Context, opts DispatchOpts) (Handle, error)\n    Status(handle Handle) (DispatchStatus, error)\n    CaptureOutput(handle Handle) (string, error)\n    Kill(handle Handle) error\n    Cleanup(handle Handle) error\n}\n\ntype DispatchOpts struct {\n    BeadID     string\n    Agent      string\n    Prompt     string\n    WorkDir    string\n    CLI        string            // claude, codex, kilo, aider, kimi, openclaw\n    CLIArgs    []string          // from config template\n    Model      string\n    ModelFlag  string\n    ApprovalFlags []string\n    PromptMode string            // argument, stdin, tempfile\n    Env        map[string]string\n    Timeout    time.Duration     // tier-aware\n    LogPath    string            // where to write stdout/stderr\n    Branch     string            // ctx/{bead-id} for git isolation\n}\n\ntype Handle struct {\n    ID         string   // PID (string) for headless, session name for tmux\n    Backend    string   // headless, tmux, openclaw\n    LogPath    string   // output capture location\n    Branch     string   // git branch name\n}\n\ntype DispatchStatus struct {\n    State    string  // running, exited, gone\n    ExitCode int\n    Duration time.Duration\n}\n```\n\n### Config Shape (Complete)\n\n```toml\n[dispatch]\nlog_dir = '~/.local/share/cortex/logs'\nlog_retention_days = 30\n\n[dispatch.routing]\nfast = 'headless'\nbalanced = 'headless'\npremium = 'tmux'\ncomms = 'openclaw'\nretry_backend = 'tmux'\n\n[dispatch.timeouts]\nfast = '15m'\nbalanced = '45m'\npremium = '120m'\n\n[dispatch.git]\nbranch_prefix = 'ctx'\nbranch_cleanup_days = 7\nmerge_strategy = 'rebase'     # or 'merge'\nmax_concurrent_per_project = 3\n\n[dispatch.tmux]\nhistory_limit = 50000\nsession_prefix = 'ctx'\n\n[dispatch.cli.claude]\ncmd = 'claude'\nprompt_mode = 'argument'\nargs = ['-p', '{prompt}']\nmodel_flag = '--model'\napproval_flags = ['--dangerously-skip-permissions']\n\n[dispatch.cli.codex]\ncmd = 'codex'\nprompt_mode = 'argument'\nargs = ['-q', '{prompt}']\nmodel_flag = '--model'\napproval_flags = ['--auto-approve']\n\n[dispatch.cli.kilo]\ncmd = 'kilo'\nprompt_mode = 'argument'\nargs = ['run', '--auto', '{prompt}']\nmodel_flag = '--model'\napproval_flags = []\n\n[dispatch.cli.aider]\ncmd = 'aider'\nprompt_mode = 'argument'\nargs = ['--message', '{prompt}', '--yes', '--no-git']\nmodel_flag = '--model'\napproval_flags = ['--yes']\n\n[dispatch.cli.kimi]\ncmd = 'kimi'\nprompt_mode = 'argument'\nargs = ['--print', '{prompt}']\nmodel_flag = ''\napproval_flags = []\n\n[providers.claude-opus]\ntier = 'premium'\nauthed = true\ncli = 'claude'\nmodel = 'opus'\n\n[providers.claude-sonnet]\ntier = 'balanced'\nauthed = true\ncli = 'claude'\nmodel = 'sonnet'\n\n[providers.openai-codex]\ntier = 'premium'\nauthed = true\ncli = 'codex'\nmodel = 'gpt-5.3-codex'\n\n[providers.openai-spark]\ntier = 'fast'\nauthed = true\ncli = 'codex'\nmodel = 'gpt-5.3-spark'\n\n[providers.kilo-free]\ntier = 'fast'\nauthed = false\ncli = 'kilo'\nmodel = 'minimax/m2.1'\n\n[providers.aider-free]\ntier = 'fast'\nauthed = false\ncli = 'aider'\nmodel = 'openrouter/qwen3-coder'\n\n[providers.kimi]\ntier = 'premium'\nauthed = true\ncli = 'kimi'\nmodel = 'moonshot-v1'\n```\n\n### Migration Steps\n\n1. Add Backend interface + HeadlessCLI, Tmux, OpenClaw implementations\n2. Add dispatch.cli, dispatch.routing, dispatch.timeouts config sections\n3. Add log_path, session_name, branch columns to dispatches table\n4. Update provider config: add cli + model fields\n5. Update scheduler: pick backend based on tier + retry count\n6. Update scheduler: create ctx/ branch before dispatch, merge after\n7. Update health monitor: tier-aware timeouts, CLI availability checks, tmux health, branch cleanup\n8. Update learner: read captured output for failure/success analysis\n9. Update rate limiter: CLI fallback within tier before tier downgrade\n10. Keep existing OpenClaw dispatcher for comms — no changes to reporter","status":"in_progress","priority":2,"issue_type":"feature","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:09:32.66414023+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:58:09.865906894+10:00"}
{"id":"cortex-des","title":"Extend health monitor: CLI checks, tmux health, branch cleanup","description":"Add to internal/health/health.go:\n\n1. CLI availability: on startup + hourly, run 'which {cli}' for each configured CLI. Log warning if missing, error if all CLIs in a tier unavailable.\n2. tmux server health: 'tmux info' on health tick. If dead and tmux backend configured, log error.\n3. Auth spot-check: run '{cli} --version' for each CLI to verify it executes. Not a full auth test but catches broken installs.\n4. Branch cleanup: prune ctx/* branches older than dispatch.git.branch_cleanup_days.\n5. Log cleanup: delete dispatch log files older than dispatch.log_retention_days.\n\nNew health event types: cli_missing, cli_auth_failed, tmux_server_down, branch_cleanup, log_cleanup.\n\nAcceptance: health monitor catches missing CLIs, dead tmux, stale branches/logs.","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:56.138600204+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:56.138600204+10:00"}
{"id":"cortex-ejd","title":"Implement Tmux backend","description":"Create internal/dispatch/tmux.go implementing Backend interface.\n\n- SessionName: ctx-{project}-{bead-id}-{timestamp}, sanitize dots/colons to dashes\n- Dispatch: tmux new-session -d -s {name} -c {workdir} '{cmd}' with remain-on-exit on, history-limit from config\n- Environment variables set inline in command string (not set-environment)\n- Status: tmux display-message -t {name} -p '#{pane_dead} #{pane_dead_status}'\n  - Returns running/exited/gone + exit code\n- CaptureOutput: tmux capture-pane -t {name} -p -S -\n- Kill: send C-c, wait 5s, tmux kill-session -t {name}\n- Cleanup: kill dead sessions, list with tmux list-sessions filtered by prefix\n- ListCortexSessions: find all ctx-* sessions for orphan detection\n\nAcceptance: can dispatch any CLI inside tmux. Attach to watch. Exit codes captured. Dead sessions cleaned.","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:11.154816007+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:11.154816007+10:00","dependencies":[{"issue_id":"cortex-ejd","depends_on_id":"cortex-hr2","type":"blocks","created_at":"2026-02-17T18:01:22.919643216+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-ejd","depends_on_id":"cortex-q3c","type":"blocks","created_at":"2026-02-17T18:01:23.295677877+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-evu","title":"Test coverage gaps","description":"Several packages have zero or insufficient test coverage. The learner package (reporter, retro, outcomes) is completely untested. No scheduler end-to-end tests. No concurrency/race condition tests.\n\nKey deliverables:\n- Learner package tests (reporter, retro, outcomes)\n- Scheduler RunTick end-to-end test\n- Concurrency/race condition tests (go test -race)\n- cmd/cortex integration test\n- Failure injection tests (DB failure mid-transaction)","status":"open","priority":2,"issue_type":"epic","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:57:33.885212764+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:57:33.885212764+10:00"}
{"id":"cortex-evu.1","title":"Add learner package tests","description":"The entire learner package (reporter.go, retro.go, outcomes.go) has ZERO tests.\n\nCreate test files:\n\ninternal/learner/reporter_test.go:\n- Test SendDigest produces correct markdown format\n- Test SendAlert dedup (same alert within 1h suppressed)\n- Test SendAlert after 1h sends again\n- Test dispatchMessage calls dispatcher correctly\n\ninternal/learner/retro_test.go:\n- Test GenerateWeeklyRetro with sample dispatch data\n- Test generateRecommendations with high failure rate provider\n- Test generateRecommendations with high misclassification tier\n- Test FormatRetroMarkdown produces valid markdown table\n- Test with empty data (no dispatches in window)\n\ninternal/learner/outcomes_test.go:\n- Test GetProviderStats aggregation correctness\n- Test GetProviderStats with multiple providers\n- Test GetTierAccuracy with underestimated/overestimated cases\n- Test GetProjectVelocity calculation\n- Test with zero dispatches (edge case)\n\nAll tests should use an in-memory SQLite DB with seeded test data.\n\nAcceptance: All learner package functions tested, edge cases covered, tests pass","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:53.781414746+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:53.781414746+10:00","labels":["code","test"],"dependencies":[{"issue_id":"cortex-evu.1","depends_on_id":"cortex-evu","type":"parent-child","created_at":"2026-02-17T18:00:53.784186502+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-evu.2","title":"Add scheduler RunTick end-to-end test","description":"No test exercises the full RunTick pipeline. Individual pieces are tested but the integration isn't.\n\nCreate internal/scheduler/scheduler_test.go:\n\nTest scenarios:\n1. **Happy path**: project with 2 ready beads, providers available → dispatches 2\n2. **Rate limited**: all authed providers exhausted → uses free tier\n3. **All providers exhausted**: nothing available → dispatches 0, logs warning\n4. **Already dispatched**: bead already running → skips\n5. **Epic skipped**: bead type=epic → skipped\n6. **Max per tick**: 5 ready beads, max_per_tick=2 → dispatches 2\n7. **Agent busy**: agent already has running dispatch → skips bead\n8. **Multiple projects**: 2 projects, priority ordering respected\n9. **Dependency filtering**: bead with unresolved dep → not in ready list\n\nTest infrastructure:\n- Mock Dispatcher that records calls instead of spawning processes\n- In-memory SQLite store with seeded data\n- Mock beads.ListBeads that returns controlled bead lists\n- Controlled config with test providers/tiers\n\nAcceptance: All 9 scenarios tested, mock infrastructure reusable, tests pass","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:59.580331566+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:59.580331566+10:00","labels":["code","test"],"dependencies":[{"issue_id":"cortex-evu.2","depends_on_id":"cortex-evu","type":"parent-child","created_at":"2026-02-17T18:00:59.583406157+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-evu.3","title":"Add concurrency and race condition tests","description":"No race condition testing exists. Multiple goroutines access shared state (store, rate limiter, config).\n\nTests to add:\n\n1. **Store concurrent access**: parallel RecordDispatch + GetRunningDispatches\n   - SQLite WAL mode should handle this but verify\n\n2. **Rate limiter concurrent access**: parallel CanDispatchAuthed + RecordAuthedDispatch\n   - Verify atomic counting under concurrent access\n\n3. **Scheduler + Health concurrent**: RunTick and CheckStuckDispatches running simultaneously\n   - Both read/write dispatches table\n\n4. **Config reload concurrent**: SIGHUP reload during RunTick\n   - Config pointer swap must be atomic\n\n5. **Reporter dedup concurrent**: parallel SendAlert calls\n   - alertSent map accessed under mutex\n\nRun all with: go test -race ./...\n\nAdd to Makefile: make test-race target\n\nAcceptance: All concurrent scenarios tested, go test -race passes with zero races detected","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:01:04.677579028+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:01:04.677579028+10:00","labels":["code","test"],"dependencies":[{"issue_id":"cortex-evu.3","depends_on_id":"cortex-evu","type":"parent-child","created_at":"2026-02-17T18:01:04.68040738+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-evu.4","title":"Add cmd/cortex integration test","description":"The main entry point has no tests. Add an integration test that starts and stops cortex.\n\nCreate cmd/cortex/main_test.go:\n\nTest scenarios:\n1. **Startup and shutdown**: start with valid config, send SIGINT, verify clean exit\n2. **Invalid config**: start with bad config, verify error message and exit code 1\n3. **--once mode**: start with --once, verify single tick runs and process exits\n4. **--dry-run mode**: start with --dry-run --once, verify no dispatches made\n5. **Lock contention**: start two instances, verify second exits with lock error\n6. **API responds**: start, hit /status endpoint, verify 200 response\n\nTest infrastructure:\n- Temp directory with test cortex.toml\n- Temp SQLite DB\n- Short tick interval (100ms) for fast tests\n- Mock project with no beads (so nothing dispatches)\n\nAcceptance: Main entry point tested, startup/shutdown/flags verified, test cleanup thorough","status":"open","priority":3,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:01:15.101446797+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:01:15.101446797+10:00","labels":["code","test"],"dependencies":[{"issue_id":"cortex-evu.4","depends_on_id":"cortex-evu","type":"parent-child","created_at":"2026-02-17T18:01:15.10472643+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-f4n","title":"Phase 4: Self-Improving + Reporter","description":"Outcome detection (poll bd list for closed beads), duration tracking, weekly retro analysis of dispatches table, tier mismatch flagging, provider weight adjustment. Daily digest and event-driven alerts via Matrix through openclaw agent.","status":"closed","priority":2,"issue_type":"epic","owner":"simon.heikkila@gmail.com","estimated_minutes":240,"created_at":"2026-02-17T13:40:10.459102604+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:59:27.332196582+10:00","closed_at":"2026-02-17T14:59:27.332196582+10:00","close_reason":"Closed","labels":["learner","phase-4","reporter"]}
{"id":"cortex-f4n.1","title":"Outcome tracking + duration logging","description":"Implement internal/learner/outcomes.go — tracks task completion outcomes for learning.\n\nFunctions:\n- RecordOutcome(dispatch Dispatch, bead Bead) -\u003e error\n  Called when a dispatch transitions to completed or failed.\n  Records: bead_id, tier used, provider used, duration_s, exit_code, retries needed, escalated_from_tier.\n  \n- GetProviderStats(window time.Duration) -\u003e map[string]ProviderStats\n  Aggregates per-provider: total dispatches, avg duration, success rate, failure rate.\n  \n- GetTierAccuracy(window time.Duration) -\u003e map[string]TierAccuracy\n  Compares assigned tier vs actual duration:\n  - If a 'fast' tier task took \u003e90min -\u003e tier was underestimated\n  - If a 'premium' tier task took \u003c30min -\u003e tier was overestimated\n  Returns misclassification rate per tier.\n\n- GetProjectVelocity(project string, window time.Duration) -\u003e ProjectVelocity\n  Beads completed, avg time per bead, throughput (beads/day).\n\nAll data sourced from the dispatches table in store.\n\nAcceptance criteria:\n- Outcomes recorded on every dispatch completion\n- Provider stats accurately reflect success/failure rates\n- Tier accuracy detects misclassifications\n- Project velocity calculated correctly\n- Unit tests with seeded dispatch data","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":60,"created_at":"2026-02-17T14:22:59.384589683+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:59:23.196454397+10:00","closed_at":"2026-02-17T14:59:23.196454397+10:00","close_reason":"Closed","labels":["learner","phase-4"],"dependencies":[{"issue_id":"cortex-f4n.1","depends_on_id":"cortex-f4n","type":"parent-child","created_at":"2026-02-17T14:22:59.405866381+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-f4n.1","depends_on_id":"cortex-08z.3","type":"blocks","created_at":"2026-02-17T14:22:59.427225835+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-f4n.2","title":"Weekly retrospective analysis","description":"Implement internal/learner/retro.go — generates a weekly retrospective report analyzing Cortex's performance.\n\nFunction:\n- GenerateWeeklyRetro() -\u003e RetroReport\n  Analyzes the past 7 days of dispatches data:\n  \n  1. Summary stats: total dispatches, completed, failed, stuck, avg duration\n  2. Provider performance: per-provider success rate, avg duration, failure modes\n  3. Tier accuracy: how often was the tier classification correct vs actual duration\n     - Underestimates (fast task took premium time) -\u003e suggest label adjustment\n     - Overestimates (premium task was trivial) -\u003e suggest downgrade\n  4. Project velocity: beads/day per project, backlog burn rate, ETA to empty\n  5. Rate limiter utilization: peak 5h window usage, weekly usage, headroom triggers\n  6. Recommendations: auto-generated suggestions like:\n     - 'Provider X had 40% failure rate — consider deprioritizing'\n     - 'Tier fast is overloaded — raise threshold to 45min'\n     - 'Project Y stalled — 0 beads completed in 3 days'\n\n- FormatRetroMarkdown(report RetroReport) -\u003e string\n  Formats the report as a clean markdown message suitable for Matrix delivery.\n\nScheduled: runs on config.Reporter.WeeklyRetroDay (default: Monday).\n\nAcceptance criteria:\n- Retro covers all 5 analysis dimensions\n- Recommendations are actionable and specific\n- Markdown output is clean and readable\n- Unit tests with seeded week of dispatch data\n- Handles edge case: no dispatches in the past week","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":60,"created_at":"2026-02-17T14:24:18.47563934+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:59:23.214396431+10:00","closed_at":"2026-02-17T14:59:23.214396431+10:00","close_reason":"Closed","labels":["learner","phase-4"],"dependencies":[{"issue_id":"cortex-f4n.2","depends_on_id":"cortex-f4n","type":"parent-child","created_at":"2026-02-17T14:24:18.494227535+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-f4n.2","depends_on_id":"cortex-f4n.1","type":"blocks","created_at":"2026-02-17T14:24:18.649189004+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-f4n.3","title":"Daily digest + event-driven Matrix alerts","description":"Implement Matrix integration for Cortex reporting via openclaw agent dispatch.\n\nDaily digest (scheduled at config.Reporter.DailyDigestTime, default 09:00 AEST):\n- Dispatches the 'main' agent with a formatted status message:\n  ## Daily Cortex Digest — {date}\n  - **{project}:** {completed} beads completed, {ready} ready, {running} in progress\n  - **Providers:** {provider} {used}/{cap} for each authed provider\n  - **Health:** {events_count} events, {restarts} restarts\n  - **Next up:** {top_3_ready_beads}\n\n- Command: openclaw agent --agent main --message {digest} --deliver --reply-channel matrix --reply-to {room_id}\n\nEvent-driven alerts (immediate, not scheduled):\nCortex sends immediate alerts for:\n1. Task failed after max retries -\u003e includes bead ID, error details, retry history\n2. Gateway down for \u003e5min -\u003e includes restart attempts, last error\n3. Provider weekly quota \u003e80% -\u003e includes current usage, projected depletion\n\nImplementation:\n- internal/reporter/reporter.go with Reporter struct\n- SendDigest() method for daily digest\n- SendAlert(alertType, message) for event-driven alerts\n- Both use dispatcher.Dispatch to send via openclaw agent\n\nAcceptance criteria:\n- Daily digest sent at configured time with accurate stats\n- Event alerts sent immediately on trigger conditions\n- Messages formatted as readable markdown\n- Does not send duplicate alerts for same event within 1h (dedup)\n- Unit tests verify message formatting and dedup logic","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":60,"created_at":"2026-02-17T14:25:20.620008341+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:59:23.233750686+10:00","closed_at":"2026-02-17T14:59:23.233750686+10:00","close_reason":"Closed","labels":["phase-4","reporter"],"dependencies":[{"issue_id":"cortex-f4n.3","depends_on_id":"cortex-f4n","type":"parent-child","created_at":"2026-02-17T14:25:20.645509375+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-f4n.3","depends_on_id":"cortex-08z.8","type":"blocks","created_at":"2026-02-17T14:25:20.725842446+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-f4n.3","depends_on_id":"cortex-f4n.1","type":"blocks","created_at":"2026-02-17T14:25:20.80543788+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-grt","title":"Implement git branch isolation for concurrent dispatches","description":"Add git branch management to the dispatch flow in scheduler:\n\nBefore dispatch:\n1. git checkout -b ctx/{bead-id} from main branch\n2. Pass branch name in DispatchOpts\n\nAfter dispatch completes (success):\n1. git checkout main\n2. git merge ctx/{bead-id} (or rebase per config merge_strategy)\n3. Handle merge conflicts: mark dispatch as 'conflict', create retry bead\n4. Delete branch on successful merge\n\nAfter dispatch fails/stuck:\n1. Leave branch for debugging\n2. Clean up branches older than branch_cleanup_days on health tick\n\nAdd to health monitor: periodic branch cleanup (prune ctx/* older than 7 days).\n\nAcceptance: parallel dispatches on same project don't conflict. Branches created/merged/cleaned automatically.","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:38.507365878+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:38.507365878+10:00"}
{"id":"cortex-hgz","title":"Add log_path, session_name, branch columns to dispatches table","description":"Extend the dispatches table in internal/store/store.go:\n- log_path TEXT: path to stdout/stderr capture file\n- session_name TEXT: tmux session name (null for headless/openclaw)\n- branch TEXT: git branch name (ctx/{bead-id})\n- backend TEXT: which backend was used (headless, tmux, openclaw)\n\nAdd migration logic (ALTER TABLE or recreate). Update RecordDispatch, UpdateDispatchStatus, GetRunningDispatches to handle new columns.\n\nAcceptance: schema migrates cleanly from old format. New columns queryable.","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:00.421367386+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:00.421367386+10:00","dependencies":[{"issue_id":"cortex-hgz","depends_on_id":"cortex-hr2","type":"blocks","created_at":"2026-02-17T18:01:14.93849003+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-hr2","title":"Add dispatch config structs (cli, routing, timeouts, git, tmux)","description":"Add new config sections to internal/config/config.go and cortex.toml:\n- dispatch.cli.{name}: cmd, prompt_mode, args, model_flag, approval_flags per CLI\n- dispatch.routing: fast/balanced/premium/comms backend selection, retry_backend\n- dispatch.timeouts: per-tier timeout values (fast=15m, balanced=45m, premium=120m)\n- dispatch.git: branch_prefix, branch_cleanup_days, merge_strategy, max_concurrent_per_project\n- dispatch.tmux: history_limit, session_prefix\n- dispatch.log_dir, dispatch.log_retention_days\n- Update provider config: add cli and model fields\n- Parse and validate all new sections\n- Update cortex.toml with new sections\n\nAcceptance: config loads, validates, and all new fields accessible. Existing config still works.","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:59:51.596871157+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:59:51.596871157+10:00"}
{"id":"cortex-hrz","title":"Dry-run mode and control plane API","description":"No way to preview what Cortex would do without actually dispatching. API is read-only — can't pause, cancel, or retry dispatches. Must restart the process to change config. Makes operations risky and debugging hard.\n\nKey deliverables:\n- --dry-run flag: run tick logic, log what would dispatch, don't actually do it\n- Control API: cancel, retry, pause/resume scheduler\n- Config reload via SIGHUP (no restart needed)\n- Dispatch history query API\n- Per-bead status API","status":"open","priority":1,"issue_type":"epic","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:57:33.432561494+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:57:33.432561494+10:00"}
{"id":"cortex-hrz.1","title":"Add --dry-run flag to scheduler","description":"Add a --dry-run mode that runs the full tick logic but doesn't actually dispatch agents.\n\nChanges to cmd/cortex/main.go:\n- Add --dry-run flag\n- Pass dryRun bool to Scheduler\n\nChanges to internal/scheduler/scheduler.go:\n- Accept dryRun field on Scheduler struct\n- In RunTick, when dryRun=true:\n  - Run all discovery, filtering, role inference, complexity detection, provider selection\n  - Log what WOULD be dispatched: bead, project, agent, role, tier, provider\n  - Do NOT call dispatcher.Dispatch()\n  - Do NOT record dispatch in store\n  - Do NOT record rate limit usage\n- Output format: structured log entries with 'dry_run=true' tag\n\nAlso add --once flag behavior (already exists) so --dry-run --once shows one tick preview and exits.\n\nAcceptance: --dry-run shows exactly what would dispatch without side effects, combined with --once for single preview","status":"open","priority":1,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:00.56660378+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:00.56660378+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-hrz.1","depends_on_id":"cortex-hrz","type":"parent-child","created_at":"2026-02-17T18:00:00.569202103+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-hrz.2","title":"Add control API: cancel, retry, pause/resume","description":"Add write endpoints to the API for controlling the scheduler.\n\nNew endpoints in internal/api/api.go:\n\nPOST /scheduler/pause\n- Sets scheduler paused flag\n- Running dispatches continue but no new dispatches\n- Returns: {paused: true}\n\nPOST /scheduler/resume\n- Clears paused flag\n- Returns: {paused: false}\n\nPOST /dispatches/{id}/cancel\n- Kill the running dispatch (SIGTERM → SIGKILL)\n- Mark as failed with reason 'cancelled'\n- Returns: {cancelled: true}\n\nPOST /dispatches/{id}/retry\n- Re-dispatch a failed dispatch with same bead/project/role\n- Optionally specify tier override: ?tier=premium\n- Returns: new dispatch info\n\nGET /dispatches\n- Query dispatch history with filters\n- ?status=failed\u0026project=hg-website\u0026limit=50\u0026offset=0\n- Returns: paginated dispatch list with all fields\n\nGET /dispatches/{id}\n- Full dispatch detail: prompt, output (if captured), duration, cost, diagnosis\n\nScheduler changes:\n- Add Paused() bool method, check at top of RunTick\n- Add CancelDispatch(id) method\n\nAcceptance: All endpoints work, pause prevents new dispatches, cancel kills running, retry re-dispatches","status":"open","priority":1,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:06.476355397+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:06.476355397+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-hrz.2","depends_on_id":"cortex-hrz","type":"parent-child","created_at":"2026-02-17T18:00:06.479998177+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-hrz.3","title":"Implement config reload via SIGHUP","description":"Allow reloading cortex.toml without restarting the process.\n\nChanges to cmd/cortex/main.go:\n- Add SIGHUP signal handler\n- On SIGHUP: re-read and validate config file\n- If valid: swap config pointer in scheduler, rate limiter, health monitor\n- If invalid: log error, keep old config\n- Log: 'config reloaded' or 'config reload failed: {reason}'\n\nChanges to internal/config/config.go:\n- Add Reload(path) (*Config, error) function (same as Load but can be called multiple times)\n\nThread safety:\n- Config access must be behind sync.RWMutex or atomic pointer swap\n- Scheduler reads config under RLock\n- SIGHUP handler writes under Lock\n\nWhat CAN be reloaded:\n- Provider definitions (add/remove/modify)\n- Tier assignments\n- Rate limit caps\n- Project enable/disable\n- Log level\n- Tick interval\n\nWhat CANNOT be reloaded (requires restart):\n- State DB path\n- API bind address\n\nAcceptance: SIGHUP reloads config, invalid config rejected, thread-safe, logs reload status","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:12.411538173+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:12.411538173+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-hrz.3","depends_on_id":"cortex-hrz","type":"parent-child","created_at":"2026-02-17T18:00:12.414345728+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-hrz.4","title":"Add per-bead status API endpoint","description":"API endpoint to check the dispatch status of a specific bead.\n\nNew endpoint:\nGET /beads/{id}\n- Returns: bead ID, project, current dispatch status (running/completed/failed/not_dispatched)\n- If dispatched: agent, provider, tier, duration, started_at\n- If completed: duration, quality score (if available), cost (if tracked)\n- If failed: failure diagnosis, retry count\n- Dispatch history: all dispatches for this bead (may have been retried)\n\nImplementation:\n- Query dispatches table by bead_id\n- Join with dispatch_output for tail (if available)\n- Join with quality scores (if available)\n\nGET /beads/{id}/output\n- Returns: full captured output for the most recent dispatch of this bead\n- 404 if no output captured\n\nAcceptance: Bead status queryable, includes full dispatch history, output accessible","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:17.923927769+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:17.923927769+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-hrz.4","depends_on_id":"cortex-hrz","type":"parent-child","created_at":"2026-02-17T18:00:17.927023179+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-j5d","title":"Output capture and agent feedback loop","description":"Cortex is blind to what its agents do. Dispatches go to /dev/null — no stdout, no stderr, no output. When a dispatch completes, Cortex knows 'PID died' and nothing else. Can't tell if the agent wrote good code, broke tests, or went off-rails.\n\nA TmuxDispatcher already exists in internal/dispatch/tmux.go (294 lines, full output capture via tmux sessions) but is NOT wired into the scheduler. This is the lowest-hanging highest-impact fix in the project.\n\nWithout output capture, every other intelligence feature (quality scoring, learning, retro analysis) is building on sand.\n\nKey deliverables:\n- Integrate TmuxDispatcher into scheduler (replace PID-based dispatcher)\n- Store agent output in DB (new output/logs table)\n- Failure diagnostics: capture why agents fail\n- Quality scoring: assess if agent work actually addressed the bead\n- Feedback loop: use outcomes to improve provider selection and prompting","status":"open","priority":0,"issue_type":"epic","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:54:00.463246196+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:54:00.463246196+10:00"}
{"id":"cortex-j5d.1","title":"Integrate TmuxDispatcher into scheduler","description":"Replace the PID-based Dispatcher with the TmuxDispatcher that already exists in internal/dispatch/tmux.go.\n\nThe TmuxDispatcher is already implemented (294 lines) but not wired into the scheduler. It uses tmux sessions instead of bare PIDs, giving us:\n- Output capture via tmux capture-pane\n- Session state queryable (running vs exited vs gone)\n- Survives parent crash (tmux server persistence)\n- Graceful shutdown orchestration\n- Session naming: ctx-{project}-{beadID}-{timestamp}\n\nChanges needed:\n- Update scheduler.go to use TmuxDispatcher instead of Dispatcher\n- Update health/stuck.go to use tmux session checks instead of PID checks\n- Update health/zombie.go to use tmux list-sessions instead of pgrep\n- Update main.go wiring to create TmuxDispatcher\n- Add tmux availability check on startup (fall back to PID if tmux unavailable)\n- Update dispatch tests\n\nThe TmuxDispatcher already implements the same Dispatch() signature. This should be largely a wiring change.\n\nAcceptance: Scheduler uses tmux sessions, health checks use tmux, zombie detection uses tmux list-sessions, fallback to PID-based if tmux not available","status":"open","priority":0,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:58:32.59587345+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:58:32.59587345+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-j5d.1","depends_on_id":"cortex-j5d","type":"parent-child","created_at":"2026-02-17T17:58:32.599292194+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-j5d.2","title":"Add agent output storage to DB","description":"Create a mechanism to capture and store agent output from tmux sessions.\n\nNew table in internal/store/store.go:\n```sql\nCREATE TABLE dispatch_output (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    dispatch_id INTEGER NOT NULL REFERENCES dispatches(id),\n    captured_at TEXT NOT NULL,\n    output TEXT NOT NULL,        -- full scrollback capture\n    output_tail TEXT NOT NULL,   -- last 100 lines (for quick queries)\n    output_bytes INTEGER NOT NULL\n);\nCREATE INDEX idx_dispatch_output_dispatch ON dispatch_output(dispatch_id);\n```\n\nNew methods:\n- CaptureOutput(dispatchID, output string) error\n- GetOutput(dispatchID) (string, error)\n- GetOutputTail(dispatchID) (string, error)\n\nCapture trigger: when scheduler detects dispatch completion (PID dead / tmux session exited), call TmuxDispatcher.CaptureOutput(sessionName) and store result.\n\nSize management: truncate output to max 500KB per dispatch. Store full output and last-100-lines tail separately for quick queries.\n\nAcceptance: Output captured on completion, stored in DB, queryable, size-bounded","status":"open","priority":0,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:58:43.045623658+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:58:43.045623658+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-j5d.2","depends_on_id":"cortex-j5d","type":"parent-child","created_at":"2026-02-17T17:58:43.050767436+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-j5d.2","depends_on_id":"cortex-j5d.1","type":"blocks","created_at":"2026-02-17T17:59:13.874165757+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-j5d.3","title":"Add failure diagnostics from captured output","description":"Use captured agent output to diagnose why dispatches fail. Pure code — pattern matching on output.\n\nCreate internal/learner/diagnostics.go:\n```go\ntype FailureDiagnosis struct {\n    DispatchID  int\n    BeadID      string\n    Category    string    // compile_error, test_failure, timeout, rate_limited, permission_denied, unknown\n    Summary     string    // first relevant error line\n    Details     string    // surrounding context\n}\n\n// DiagnoseFailure scans captured output for known failure patterns\nfunc DiagnoseFailure(output string) *FailureDiagnosis\n\n// Known patterns (regex):\n// - 'FAIL' or 'FAILED' → test_failure\n// - 'cannot find package' or 'undefined:' → compile_error\n// - 'permission denied' → permission_denied\n// - 'rate limit' or '429' → rate_limited\n// - 'context deadline exceeded' → timeout\n// - 'error:' or 'Error:' → generic error extraction\n```\n\nStore failure diagnosis:\n- Add category and summary columns to dispatches table (nullable, backward compat)\n- Populate on failure detection\n\nIntegration:\n- scheduler checkRunningDispatches: on failure, run DiagnoseFailure and store\n- Include in per-project retro data\n- Surface in API: GET /dispatches/{id} includes diagnosis\n\nAcceptance: Common failure patterns detected, categorized, stored, surfaced in API","status":"open","priority":1,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:58:49.427555396+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:58:49.427555396+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-j5d.3","depends_on_id":"cortex-j5d","type":"parent-child","created_at":"2026-02-17T17:58:49.4310444+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-j5d.3","depends_on_id":"cortex-j5d.2","type":"blocks","created_at":"2026-02-17T17:59:18.506066419+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-j5d.4","title":"Implement agent quality scoring","description":"Score completed dispatches on quality. Mostly code for objective checks, optional LLM for nuanced review.\n\n**Code-based scoring (internal/learner/quality.go):**\n```go\ntype QualityScore struct {\n    DispatchID    int\n    Overall       float64  // 0.0-1.0\n    TestsPassed   *bool    // did tests pass? (nil if no tests)\n    BeadClosed    bool     // did agent close the bead?\n    CommitMade    bool     // did agent make a git commit?\n    FilesChanged  int      // how many files touched\n    LinesChanged  int      // net lines changed\n    Duration      float64  // seconds (shorter = better, within reason)\n}\n\n// ScoreDispatch analyzes output and git state to score quality\nfunc ScoreDispatch(output string, workspace string, beadID string) (*QualityScore, error)\n```\n\nDetection from output (code):\n- Search for 'PASS' / 'FAIL' / 'ok' in test output\n- Search for 'bd close' confirmation\n- Parse git diff stats from output\n- Check bead status via bd show\n\nStore scores:\n- New quality_scores table or add score columns to dispatches\n- Track per-provider, per-role average scores\n\nUse in provider selection:\n- If provider X has avg quality \u003c 0.5 on role Y, deprioritize\n\nOptional LLM scoring (future enhancement):\n- For high-value beads, dispatch a reviewer agent to assess the output\n- 'Did this agent actually address the acceptance criteria?'\n\nAcceptance: Objective quality metrics computed from output, stored, available for provider selection","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:58:56.169972921+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:58:56.169972921+10:00","dependencies":[{"issue_id":"cortex-j5d.4","depends_on_id":"cortex-j5d","type":"parent-child","created_at":"2026-02-17T17:58:56.188579404+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-j5d.4","depends_on_id":"cortex-j5d.2","type":"blocks","created_at":"2026-02-17T17:59:21.999612183+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-j5d.5","title":"Close the feedback loop: outcome-driven improvements","description":"Use quality scores and failure diagnostics to automatically improve Cortex's behavior over time. Mostly code with some data feeding into LLM retros.\n\n**Automated improvements (code):**\n\n1. Provider scoring adjustment:\n   - Track rolling quality score per provider per role\n   - If provider drops below threshold (e.g. 0.4), auto-deprioritize for that role\n   - If provider consistently scores high, prefer it\n\n2. Complexity calibration:\n   - Compare estimated complexity (tier) vs actual duration and outcome\n   - If 'fast' tasks regularly fail and succeed on 'balanced', adjust threshold\n   - Store calibration data in DB, apply in DetectComplexity()\n\n3. Prompt effectiveness:\n   - Track which prompt template versions produce highest quality scores\n   - A/B test: randomly vary prompt details, measure outcomes\n   - Store prompt template version with dispatch for correlation\n\n4. Failure pattern prevention:\n   - If same failure category repeats for same bead type, add warning to prompt\n   - e.g. 'Previous agents failed on compile errors in Go tasks — run go build before committing'\n\n**Data for LLM retros:**\n- All of the above feeds into the retro data that scrum master and chief SM analyze\n- They can produce deeper recommendations than code heuristics\n\nAcceptance: Provider scores auto-adjust, complexity thresholds calibrate, failure patterns inform future prompts","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:59:08.870978397+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:59:08.870978397+10:00","dependencies":[{"issue_id":"cortex-j5d.5","depends_on_id":"cortex-j5d","type":"parent-child","created_at":"2026-02-17T17:59:08.875157717+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-j5d.5","depends_on_id":"cortex-j5d.4","type":"blocks","created_at":"2026-02-17T17:59:25.629666695+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-j5d.5","depends_on_id":"cortex-j5d.3","type":"blocks","created_at":"2026-02-17T17:59:29.299768387+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-kib","title":"Add dispatch output capture and storage","description":"Add a dispatch_outputs table to the SQLite store (columns: dispatch_id, session_name, output TEXT, captured_at). When checkRunningDispatches detects a session has exited, call CaptureOutput(sessionName) from tmux.go to grab the full scrollback, then store it. Add Store methods: StoreDispatchOutput(dispatchID, sessionName, output) and GetDispatchOutput(dispatchID). Clean up dead tmux sessions after capture using KillSession().","acceptance_criteria":"\nACCEPTANCE CRITERIA:\n1. Add dispatch_outputs table with columns: dispatch_id, session_name, output TEXT, captured_at\n2. Extend Store with new methods: StoreDispatchOutput(dispatchID, sessionName, output) and GetDispatchOutput(dispatchID)\n3. Update checkRunningDispatches to detect exited sessions and capture their tmux output using CaptureOutput() from tmux.go\n4. Store the captured output in dispatch_outputs table\n5. Clean up dead tmux sessions after output capture using KillSession()\n6. Handle edge cases: missing sessions, capture failures, database errors\n7. Add tests for new Store methods and integration tests for output capture flow\n8. Update schema migration to handle existing deployments","status":"open","priority":0,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:57:12.333067404+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:01:06.825676905+10:00","labels":["stage:planning"],"dependencies":[{"issue_id":"cortex-kib","depends_on_id":"cortex-1b2","type":"blocks","created_at":"2026-02-17T17:57:20.50202408+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-kib","depends_on_id":"cortex-j5d","type":"parent-child","created_at":"2026-02-17T17:57:21.952772613+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-pg5","title":"Multi-workflow support: stage-based pipelines for dev, content, trading","description":"Replace single-shot dispatch with multi-stage workflow pipelines. Each workflow defines ordered stages with stage-specific roles, prompt templates, transition rules, and validation gates. A bead progresses through stages (each stage = a separate dispatch) rather than being handled in one shot.\n\nTarget workflows:\n- **Dev**: implement → test → review → merge/deploy\n- **Content**: research → draft → edit/review → publish\n- **Trading**: signal analysis → risk validation → execution → confirmation/audit\n\nKey capabilities:\n- Workflow definitions in cortex.toml config\n- Workflow engine tracking stage progression per bead\n- Stage-aware prompt building with per-stage templates\n- New roles beyond coder/reviewer/ops (writer, editor, analyst, executor, etc.)\n- DB schema extension for stage tracking (current stage, stage history, stage outputs)\n- Automatic workflow assignment based on bead labels/type\n- Gates between stages (e.g., tests must pass before review stage)\n- Manual override to skip/repeat stages\n\nThis is the largest architectural change since initial orchestrator implementation.","status":"open","priority":1,"issue_type":"epic","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:05:13.440994334+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:05:13.440994334+10:00"}
{"id":"cortex-pg5.1","title":"Define workflow data model and config schema","description":"Design and implement the core data structures for workflows.\n\nA Workflow definition needs:\n- Name (string identifier, e.g. 'dev', 'content', 'trading')\n- Stages: ordered list of Stage definitions\n- Default: bool (is this the fallback workflow?)\n- Match rules: labels/types that auto-assign this workflow\n\nA Stage definition needs:\n- Name (e.g. 'implement', 'test', 'review')\n- Role (agent role for this stage, e.g. 'coder', 'reviewer', 'writer')\n- Tier override (optional, force a specific complexity tier)\n- Prompt template key (which prompt template to use)\n- Gate (optional validation command that must succeed before advancing)\n- Auto-advance (bool: advance automatically on completion, or wait?)\n\nConfig schema in cortex.toml:\n```toml\n[workflows.dev]\ndefault = true\nmatch_labels = [\"dev\", \"code\", \"feature\", \"bug\"]\nmatch_types = [\"task\", \"bug\", \"feature\"]\n\n[[workflows.dev.stages]]\nname = \"implement\"\nrole = \"coder\"\nprompt_template = \"implement\"\n\n[[workflows.dev.stages]]\nname = \"test\"\nrole = \"reviewer\"\nprompt_template = \"test\"\ngate = \"go test ./...\"\n\n[[workflows.dev.stages]]\nname = \"review\"\nrole = \"reviewer\"\nprompt_template = \"review\"\ntier = \"premium\"\n```\n\nCreate Go types in internal/workflow/types.go\n\nAcceptance: Types compile, config can be parsed from TOML, unit test for parsing","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:06:34.87931377+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:06:34.87931377+10:00","dependencies":[{"issue_id":"cortex-pg5.1","depends_on_id":"cortex-pg5","type":"parent-child","created_at":"2026-02-17T17:06:34.929296003+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-pg5.10","title":"Add comprehensive tests for workflow system","description":"Write tests for the entire workflow system.\n\nTest files:\n- internal/workflow/types_test.go - config parsing, validation\n- internal/workflow/engine_test.go - stage progression, gate handling, completion\n- internal/workflow/prompts_test.go - template rendering per stage\n- internal/workflow/builtin_test.go - built-in workflow correctness\n- internal/store/store_test.go - new stage tracking methods\n- internal/scheduler/scheduler_test.go - workflow-integrated tick\n\nKey test scenarios:\n- Bead progresses through all stages of dev workflow\n- Gate failure prevents stage advancement\n- Bead with no matching workflow uses single-shot mode\n- Config override replaces built-in workflow\n- Stage tier override is respected\n- Concurrent beads at different stages\n- Backward compat: no workflows config = old behavior\n\nAcceptance: All tests pass, \u003e80% coverage on workflow package","notes":"**Review Result: Changes Needed**\n\nIssue: Cannot review tests for non-existent code. The workflow system has not been implemented yet.\n\nMissing Dependencies: All blocking issues are still OPEN:\n- cortex-pg5.1: Define workflow data model and config schema  \n- cortex-pg5.2: Extend config parser for workflow definitions\n- cortex-pg5.3: Extend DB schema for workflow stage tracking\n- cortex-pg5.4: Implement workflow engine for stage progression\n- cortex-pg5.5: Add stage-aware prompt templates\n- cortex-pg5.6: Extend role system for workflow-specific roles  \n- cortex-pg5.7: Update scheduler to drive workflow stages\n- cortex-pg5.8: Add built-in workflow templates\n\nMissing Files: None of the expected test files exist:\n- internal/workflow/ directory doesn't exist\n- No workflow types, engine, prompts, or builtin modules to test\n\nAction Required: Complete all dependency issues first. The workflow system must be implemented before comprehensive tests can be written.\n\nNext Steps: \n1. Implement the core workflow system (cortex-pg5.1 through cortex-pg5.8)\n2. Return this issue to review queue once all dependencies are closed\n3. Tests should achieve \u003e80% coverage on the workflow package\n\nTransitioned back to stage:coding for dependency resolution.","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:07:33.605339669+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:01:01.47428132+10:00","labels":["stage:coding","test"],"dependencies":[{"issue_id":"cortex-pg5.10","depends_on_id":"cortex-pg5","type":"parent-child","created_at":"2026-02-17T17:07:33.762863647+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.10","depends_on_id":"cortex-pg5.1","type":"blocks","created_at":"2026-02-17T17:12:49.005518011+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.10","depends_on_id":"cortex-pg5.2","type":"blocks","created_at":"2026-02-17T17:12:49.184559794+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.10","depends_on_id":"cortex-pg5.3","type":"blocks","created_at":"2026-02-17T17:12:49.3910256+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.10","depends_on_id":"cortex-pg5.4","type":"blocks","created_at":"2026-02-17T17:12:49.549064945+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.10","depends_on_id":"cortex-pg5.5","type":"blocks","created_at":"2026-02-17T17:12:49.695756234+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.10","depends_on_id":"cortex-pg5.6","type":"blocks","created_at":"2026-02-17T17:12:49.857952152+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.10","depends_on_id":"cortex-pg5.7","type":"blocks","created_at":"2026-02-17T17:12:50.019518985+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.10","depends_on_id":"cortex-pg5.8","type":"blocks","created_at":"2026-02-17T17:12:50.220371225+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.10","depends_on_id":"cortex-pg5.9","type":"blocks","created_at":"2026-02-17T17:12:50.366381872+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-pg5.2","title":"Extend config parser for workflow definitions","description":"Update internal/config/config.go to parse [workflows.*] sections from cortex.toml.\n\n- Add WorkflowConfig and StageConfig structs to Config\n- Parse match_labels, match_types, stages array\n- Validate: at least one workflow if workflows section exists\n- Validate: each stage has name and role\n- Validate: no duplicate stage names within a workflow\n- Validate: referenced roles are known\n- Backward compatible: if no [workflows] section, system works as before (single-shot)\n\nAcceptance: Config parsing works with and without workflows section, validation catches malformed configs","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:06:39.043856508+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:06:39.043856508+10:00","dependencies":[{"issue_id":"cortex-pg5.2","depends_on_id":"cortex-pg5","type":"parent-child","created_at":"2026-02-17T17:06:39.060093324+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.2","depends_on_id":"cortex-pg5.1","type":"blocks","created_at":"2026-02-17T17:12:23.303038929+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-pg5.3","title":"Extend DB schema for workflow stage tracking","description":"Add workflow stage tracking to the SQLite store (internal/store/store.go).\n\nNew table: bead_stages\n- id (auto PK)\n- bead_id (string)\n- project (string)\n- workflow (string, workflow name)\n- current_stage (string, stage name)\n- stage_index (int, 0-based position in workflow)\n- total_stages (int)\n- stage_history (JSON array of {stage, status, started_at, completed_at, dispatch_id})\n- created_at, updated_at\n\nNew methods:\n- InitBeadWorkflow(beadID, project, workflow, stages) - create tracking record\n- GetBeadStage(beadID) - current stage info\n- AdvanceStage(beadID) - move to next stage\n- RecordStageCompletion(beadID, stage, dispatchID) - log stage done\n- GetBeadsAtStage(project, stage) - query by stage\n- IsWorkflowComplete(beadID) - all stages done?\n\nUpdate dispatches table: add 'workflow' and 'stage' columns (nullable for backward compat).\n\nAcceptance: Schema migrates cleanly, methods work, existing data unaffected","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:06:44.122181075+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:06:44.122181075+10:00","dependencies":[{"issue_id":"cortex-pg5.3","depends_on_id":"cortex-pg5","type":"parent-child","created_at":"2026-02-17T17:06:44.157824257+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-pg5.4","title":"Implement workflow engine for stage progression","description":"Create internal/workflow/engine.go - the core workflow engine that drives beads through stages.\n\nEngine responsibilities:\n- AssignWorkflow(bead) → workflow name: match bead labels/type against workflow match rules, fall back to default workflow, return 'single-shot' if no workflows configured\n- GetCurrentStage(bead) → stage definition: look up where bead is in its workflow\n- ShouldDispatch(bead, stage) → bool: check if stage needs a new dispatch (not already running)\n- RunGate(bead, stage) → (passed bool, output string): execute gate command if defined\n- Advance(bead) → (nextStage, done): move to next stage or mark workflow complete\n- HandleStageCompletion(bead, dispatch) → action: when a dispatch completes, decide next action (run gate → advance or fail)\n\nThe engine sits between the scheduler and dispatcher. The scheduler calls the engine to determine what to dispatch next for each bead.\n\nKey design: the engine is stateless - all state lives in the DB (bead_stages table). Engine reads state, computes action, writes state.\n\nAcceptance: Engine correctly progresses beads through multi-stage workflows, handles gate failures, integrates with store","status":"open","priority":1,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:06:49.78662763+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:06:49.78662763+10:00","dependencies":[{"issue_id":"cortex-pg5.4","depends_on_id":"cortex-pg5","type":"parent-child","created_at":"2026-02-17T17:06:49.807644349+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.4","depends_on_id":"cortex-pg5.1","type":"blocks","created_at":"2026-02-17T17:12:23.527139002+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.4","depends_on_id":"cortex-pg5.2","type":"blocks","created_at":"2026-02-17T17:12:39.725638067+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.4","depends_on_id":"cortex-pg5.3","type":"blocks","created_at":"2026-02-17T17:12:39.924255356+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-pg5.5","title":"Add stage-aware prompt templates","description":"Extend internal/scheduler/prompt.go to support per-stage prompt templates.\n\nCurrent BuildPrompt() creates a single generic prompt. Need multiple templates:\n\nTemplates (internal/workflow/prompts.go):\n- 'implement': Current default prompt (implement the task)\n- 'test': Focus on writing/running tests for already-implemented code\n- 'review': Review code changes, check for bugs/style/security, suggest fixes\n- 'draft': Write content based on brief/outline (for content workflow)\n- 'edit': Edit/improve existing content for clarity and quality\n- 'publish': Format and prepare content for publication\n- 'analyze': Analyze data/signals and produce structured findings\n- 'validate': Check analysis against risk rules, flag concerns\n- 'execute': Execute a validated action with audit trail\n\nEach template receives the same context (bead info, workspace, acceptance criteria) but frames the task differently.\n\nBuildPrompt signature changes: BuildPrompt(bead, workspace, stage) where stage determines template selection.\n\nAlso include stage context in prompt: 'You are at stage 2/4 (test) of the dev workflow. Previous stage (implement) was completed by agent X.'\n\nAcceptance: Prompts render correctly per stage, backward compatible when no workflow","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:06:54.983770899+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:06:54.983770899+10:00","dependencies":[{"issue_id":"cortex-pg5.5","depends_on_id":"cortex-pg5","type":"parent-child","created_at":"2026-02-17T17:06:55.015798901+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.5","depends_on_id":"cortex-pg5.1","type":"blocks","created_at":"2026-02-17T17:12:23.758666929+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-pg5.6","title":"Extend role system for workflow-specific roles","description":"Extend internal/scheduler/role.go to support workflow-defined roles.\n\nCurrent roles: coder, reviewer, ops (inferred from labels).\n\nNew roles needed:\n- writer (content drafting)\n- editor (content editing/review)\n- publisher (content publishing)\n- analyst (data/signal analysis)\n- risk (risk validation)\n- executor (action execution)\n- auditor (confirmation/audit)\n\nChanges:\n- When a workflow stage specifies a role, use that role directly (no inference needed)\n- Keep InferRole() as fallback for single-shot mode (no workflow)\n- Agent naming: {project}-{role} remains the pattern\n- Add ValidateRole() to check role is known\n\nAcceptance: Workflow-specified roles override inferred roles, agent names resolve correctly","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:06:59.541458505+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:06:59.541458505+10:00","dependencies":[{"issue_id":"cortex-pg5.6","depends_on_id":"cortex-pg5","type":"parent-child","created_at":"2026-02-17T17:06:59.570084549+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.6","depends_on_id":"cortex-pg5.1","type":"blocks","created_at":"2026-02-17T17:12:23.9932262+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-pg5.7","title":"Update scheduler to drive workflow stages","description":"Modify internal/scheduler/scheduler.go RunTick to integrate the workflow engine.\n\nCurrent flow: discover beads → infer role/complexity → pick provider → dispatch\nNew flow: discover beads → assign workflow → get current stage → check gates → infer complexity (or use stage override) → pick provider → dispatch stage\n\nKey changes to RunTick:\n1. After filtering unblocked beads, call engine.AssignWorkflow() for each\n2. For workflow beads: call engine.GetCurrentStage() instead of InferRole()\n3. Use stage.Role for agent resolution (not label-inferred role)\n4. Use stage.Tier override if set, else DetectComplexity() as before\n5. Pass stage to BuildPrompt()\n6. On dispatch completion detection: call engine.HandleStageCompletion()\n   - If gate passes → engine.Advance() → next tick dispatches next stage\n   - If gate fails → mark stage failed, retry or escalate\n7. A bead is only closed (bd close) when IsWorkflowComplete() returns true\n8. Single-shot beads (no workflow match) continue working exactly as before\n\nAcceptance: Multi-stage beads progress through workflow, single-shot beads unaffected, gates enforced","status":"open","priority":1,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:07:06.913146127+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:07:06.913146127+10:00","dependencies":[{"issue_id":"cortex-pg5.7","depends_on_id":"cortex-pg5","type":"parent-child","created_at":"2026-02-17T17:07:07.012047961+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.7","depends_on_id":"cortex-pg5.4","type":"blocks","created_at":"2026-02-17T17:12:40.096220052+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.7","depends_on_id":"cortex-pg5.5","type":"blocks","created_at":"2026-02-17T17:12:40.313278826+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.7","depends_on_id":"cortex-pg5.6","type":"blocks","created_at":"2026-02-17T17:12:40.616978352+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.7","depends_on_id":"cortex-pg5.8","type":"blocks","created_at":"2026-02-17T17:12:40.828620379+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-pg5.8","title":"Add built-in workflow templates: dev, content, trading","description":"Create three built-in workflow definitions that ship with Cortex.\n\nFile: internal/workflow/builtin.go\n\n**Dev Workflow** (default=true):\n- match_labels: dev, code, feature, bug, refactor\n- match_types: task, bug, feature\n- Stages:\n  1. implement (coder) - write the code\n  2. test (reviewer, gate: 'go test ./...') - verify with tests\n  3. review (reviewer, tier: premium) - code review\n\n**Content Workflow**:\n- match_labels: content, blog, docs, copy, writing\n- match_types: docs\n- Stages:\n  1. research (analyst) - gather context and outline\n  2. draft (writer) - write first draft\n  3. edit (editor) - review and polish\n  4. publish (publisher) - format and ship\n\n**Trading Workflow**:\n- match_labels: trade, signal, execution, position\n- Stages:\n  1. analyze (analyst, tier: premium) - analyze signal/opportunity\n  2. validate (risk) - risk check and sizing\n  3. execute (executor) - place the trade\n  4. confirm (auditor) - verify execution and log\n\nBuilt-ins are used when no [workflows] config exists. If config defines workflows, they override built-ins. Provide a MergeWithBuiltins() function that lets config extend rather than replace.\n\nAcceptance: Built-in workflows available out of box, overridable via config","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:07:17.704634701+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:07:17.704634701+10:00","dependencies":[{"issue_id":"cortex-pg5.8","depends_on_id":"cortex-pg5","type":"parent-child","created_at":"2026-02-17T17:07:17.751369399+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.8","depends_on_id":"cortex-pg5.1","type":"blocks","created_at":"2026-02-17T17:12:24.197539381+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-pg5.9","title":"Add workflow status API endpoints","description":"Extend internal/api/api.go with workflow-related endpoints.\n\nNew endpoints:\n- GET /workflows - list all defined workflows with their stages\n- GET /workflows/{name} - detail view of a workflow definition\n- GET /beads/{id}/workflow - current workflow state for a bead (stage, history, progress)\n- GET /projects/{id}/pipeline - all beads grouped by their current workflow stage\n\nUpdate existing endpoints:\n- GET /status - add workflow_beads_in_progress count, beads_by_stage breakdown\n- GET /metrics - add cortex_workflow_stage_duration_seconds histogram, cortex_workflow_completions_total counter\n\nAcceptance: Endpoints return correct data, backward compatible (empty/null when no workflows)","status":"open","priority":3,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:07:25.439383905+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:07:25.439383905+10:00","dependencies":[{"issue_id":"cortex-pg5.9","depends_on_id":"cortex-pg5","type":"parent-child","created_at":"2026-02-17T17:07:25.480979113+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-pg5.9","depends_on_id":"cortex-pg5.7","type":"blocks","created_at":"2026-02-17T17:12:40.990799346+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-q3c","title":"Define Backend dispatcher interface","description":"Create internal/dispatch/backend.go with the pluggable Backend interface:\n\ntype Backend interface {\n    Dispatch(ctx context.Context, opts DispatchOpts) (Handle, error)\n    Status(handle Handle) (DispatchStatus, error)\n    CaptureOutput(handle Handle) (string, error)\n    Kill(handle Handle) error\n    Cleanup(handle Handle) error\n}\n\nPlus DispatchOpts, Handle, and DispatchStatus structs as specified in cortex-ceg design.\n\nAcceptance: interface compiles, types documented, no implementations yet.","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:59:56.012925745+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:59:56.012925745+10:00","dependencies":[{"issue_id":"cortex-q3c","depends_on_id":"cortex-hr2","type":"blocks","created_at":"2026-02-17T18:01:11.568020684+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-sfb","title":"Stage-based pipeline + auto-spawn teams","description":"Implement stage-based role inference, stage-aware prompts, agent-busy guard, stage dispatch, auto-spawn teams, and /teams API endpoint","status":"closed","priority":1,"issue_type":"feature","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:10:58.547732864+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:14:48.403083372+10:00","closed_at":"2026-02-17T17:14:48.403083372+10:00","close_reason":"Implemented stage-based pipeline with auto-spawn teams"}
{"id":"cortex-tyl","title":"Phase 2: Health \u0026 Self-Healing","description":"Gateway monitoring, stuck task detection with tier escalation, zombie process cleanup, flock mutex for single-instance enforcement. Runs as separate goroutine on 2min interval.","status":"closed","priority":2,"issue_type":"epic","owner":"simon.heikkila@gmail.com","estimated_minutes":240,"created_at":"2026-02-17T13:37:53.458300888+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:55:46.340134573+10:00","closed_at":"2026-02-17T14:55:46.340134573+10:00","close_reason":"Phase 2 complete","labels":["health","phase-2"]}
{"id":"cortex-tyl.1","title":"Gateway health monitor","description":"Implement internal/health/health.go — monitors the OpenClaw gateway service.\n\nFunction:\n- CheckGateway(unitName string) -\u003e HealthStatus\n  1. Run: systemctl --user is-active {unitName}\n  2. If inactive -\u003e attempt restart: systemctl --user restart {unitName}\n  3. If restart fails -\u003e check for stale locks/PIDs in /tmp/openclaw-gateway*, clear them, retry\n  4. Record health event to store (gateway_restart type)\n  5. Track restart count in rolling 1h window\n  6. If 3+ restarts in 1h -\u003e return critical status (triggers Matrix alert upstream)\n\nRuns as separate goroutine on config.Health.CheckInterval (default 2min).\n\nAcceptance criteria:\n- Detects inactive gateway and restarts it\n- Clears stale lock files on restart failure\n- Records all health events to SQLite\n- Escalates to alert after 3 restarts in 1h\n- Unit tests mock systemctl commands","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":60,"created_at":"2026-02-17T14:13:05.776280397+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:55:46.02130734+10:00","closed_at":"2026-02-17T14:55:46.02130734+10:00","close_reason":"Phase 2 health modules implemented with tests","labels":["health","phase-2"],"dependencies":[{"issue_id":"cortex-tyl.1","depends_on_id":"cortex-tyl","type":"parent-child","created_at":"2026-02-17T14:13:05.780322968+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-tyl.1","depends_on_id":"cortex-08z.3","type":"blocks","created_at":"2026-02-17T14:13:05.786912944+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-tyl.2","title":"Stuck task detection + tier escalation","description":"Implement internal/health/stuck.go — detects dispatched tasks that have been running too long and handles retries with tier escalation.\n\nFunction:\n- CheckStuckDispatches(timeout duration, maxRetries int) -\u003e []StuckAction\n  1. Query store.GetStuckDispatches(timeout) — dispatches WHERE status=running AND dispatched_at \u003c now()-timeout\n  2. For each stuck dispatch:\n     a. Check if PID is still alive (kill -0 pid)\n     b. If PID dead -\u003e mark status=failed in store\n     c. If PID alive but past timeout -\u003e kill it (SIGTERM, wait 5s, SIGKILL)\n     d. If retries \u003c maxRetries: re-dispatch with escalated tier (fast-\u003ebalanced-\u003epremium)\n        Set escalated_from_tier on new dispatch record\n     e. If retries \u003e= maxRetries -\u003e mark status=failed, log, return alert action\n  3. Record health events for each action taken\n\nAcceptance criteria:\n- Correctly identifies stuck dispatches past timeout\n- Dead PIDs detected and cleaned up\n- Alive-but-stuck PIDs killed gracefully\n- Tier escalation works: fast-\u003ebalanced-\u003epremium\n- Stops retrying after maxRetries, flags for alert\n- Unit tests with mock PID checks and store data","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":60,"created_at":"2026-02-17T14:19:24.632167247+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:55:46.044554518+10:00","closed_at":"2026-02-17T14:55:46.044554518+10:00","close_reason":"Phase 2 health modules implemented with tests","labels":["health","phase-2"],"dependencies":[{"issue_id":"cortex-tyl.2","depends_on_id":"cortex-tyl","type":"parent-child","created_at":"2026-02-17T14:19:24.646193963+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-tyl.2","depends_on_id":"cortex-08z.3","type":"blocks","created_at":"2026-02-17T14:19:24.70179185+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-tyl.2","depends_on_id":"cortex-08z.8","type":"blocks","created_at":"2026-02-17T14:19:24.724537621+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-tyl.3","title":"Zombie process cleanup","description":"Implement internal/health/zombie.go — finds orphaned openclaw agent processes that have no matching dispatch record.\n\nFunction:\n- CleanZombies() -\u003e int (count killed)\n  1. Run: pgrep -f 'openclaw agent' to get all PIDs running openclaw agents\n  2. Query store.GetRunningDispatches() to get all tracked PIDs\n  3. Any PID from pgrep NOT in the dispatches table is an orphan\n  4. Kill orphans: SIGTERM, wait 5s, SIGKILL if still alive\n  5. Record health event for each zombie killed (zombie_killed type)\n  6. Return count of killed processes\n\nCalled from the health check goroutine on each interval.\n\nAcceptance criteria:\n- Correctly identifies orphan processes (PID exists but no dispatch record)\n- Does NOT kill processes that are tracked in dispatches\n- Graceful kill with SIGTERM fallback to SIGKILL\n- Records health events for audit trail\n- Unit tests with mock pgrep output and store data","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":30,"created_at":"2026-02-17T14:20:27.342833336+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:55:46.083012475+10:00","closed_at":"2026-02-17T14:55:46.083012475+10:00","close_reason":"Phase 2 health modules implemented with tests","labels":["health","phase-2"],"dependencies":[{"issue_id":"cortex-tyl.3","depends_on_id":"cortex-tyl","type":"parent-child","created_at":"2026-02-17T14:20:27.385269769+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-tyl.3","depends_on_id":"cortex-08z.3","type":"blocks","created_at":"2026-02-17T14:20:27.430397688+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-tyl.3","depends_on_id":"cortex-08z.8","type":"blocks","created_at":"2026-02-17T14:20:27.496748999+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-tyl.4","title":"Single-instance flock mutex","description":"Add flock-based mutex to cmd/cortex/main.go so only one Cortex instance can run at a time.\n\nOn startup:\n1. Open lock file at /tmp/cortex.lock (or config-specified path)\n2. Attempt flock(LOCK_EX | LOCK_NB)\n3. If lock fails -\u003e log 'Another Cortex instance is running', exit 1\n4. Hold lock for lifetime of process (released on exit)\n\nUse syscall.Flock in Go.\n\nAcceptance criteria:\n- Second instance exits immediately with clear error message\n- Lock released cleanly on normal exit and SIGTERM\n- Unit test: start two instances, verify second fails","status":"closed","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","estimated_minutes":15,"created_at":"2026-02-17T14:20:43.885573502+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T14:55:46.101392206+10:00","closed_at":"2026-02-17T14:55:46.101392206+10:00","close_reason":"Phase 2 health modules implemented with tests","labels":["health","phase-2"],"dependencies":[{"issue_id":"cortex-tyl.4","depends_on_id":"cortex-tyl","type":"parent-child","created_at":"2026-02-17T14:20:43.902052012+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-tyl.4","depends_on_id":"cortex-08z.10","type":"blocks","created_at":"2026-02-17T14:20:43.922396179+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-v2h","title":"Implement HeadlessCLI backend","description":"Create internal/dispatch/headless.go implementing Backend interface.\n\n- Builds command from CLI config: cmd + args with {prompt} substitution + model_flag + model + approval_flags\n- Handles prompt_mode: argument (substitute in args), stdin (pipe), tempfile (write and pass path)\n- Redirects stdout/stderr to per-dispatch log file in log_dir\n- Returns Handle with PID and log path\n- Status: check PID alive via syscall.Kill(pid, 0)\n- CaptureOutput: read log file\n- Kill: SIGTERM, wait 5s, SIGKILL (existing pattern)\n- Cleanup: remove log file if past retention\n\nShell escaping must be safe for all prompt_modes.\n\nAcceptance: can dispatch claude -p, codex -q, kilo run --auto, aider --message headlessly. Output captured to file. Exit codes returned.","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:05.569056002+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:05.569056002+10:00","dependencies":[{"issue_id":"cortex-v2h","depends_on_id":"cortex-hr2","type":"blocks","created_at":"2026-02-17T18:01:19.241567289+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-v2h","depends_on_id":"cortex-q3c","type":"blocks","created_at":"2026-02-17T18:01:19.650720412+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-x83","title":"Wrap existing OpenClaw dispatcher as Backend interface","description":"Create internal/dispatch/openclaw.go that wraps the existing Dispatcher to implement the Backend interface.\n\n- Dispatch: delegates to existing Dispatcher.Dispatch() \n- Status: uses existing IsProcessAlive()\n- CaptureOutput: returns empty string (openclaw manages its own output via gateway)\n- Kill: uses existing KillProcess()\n- Cleanup: no-op\n\nThis preserves the existing comms/reporting path unchanged.\n\nAcceptance: existing openclaw dispatch works through new interface. Reporter still functions. No behavior change.","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T18:00:15.217111223+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T18:00:15.217111223+10:00","dependencies":[{"issue_id":"cortex-x83","depends_on_id":"cortex-q3c","type":"blocks","created_at":"2026-02-17T18:01:26.741085505+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-xhk","title":"LeSS coordination layer: cross-team orchestration","description":"Implement the Large-Scale Scrum (LeSS) coordination layer for multi-project orchestration.\n\nCurrently each project is a silo — its own beads, its own agents, its own scrum master, no awareness of other projects. This epic adds the cross-team coordination that LeSS requires: a Chief Scrum Master, cross-project dependencies, aligned cadence, shared learnings, unified ceremonies, and capacity budgeting.\n\n**Design principle:** build deterministic logic into Go code wherever possible. Only use LLM dispatch for work that requires reasoning (narrative synthesis, priority trade-offs, pattern analysis). Status aggregation, dependency graphs, scheduling, rate limit math — all code.\n\n**Key components:**\n- Cross-project dependency tracking (code)\n- Aligned sprint cadence (code)\n- Chief Scrum Master agent (LLM — the coordination brain)\n- Rate limit capacity budgeting per project (code)\n- Cross-project provider performance profiling (code + LLM)\n- Multi-team sprint planning ceremony (LLM via chief SM)\n- Overall retrospective ceremony (LLM via chief SM)\n- Unified sprint review (LLM via chief SM)\n- Definition of Done enforcement (code)\n- Predictive capacity planning (code)\n- Unified backlog API (code)","status":"open","priority":1,"issue_type":"epic","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:36:52.803737261+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:36:52.803737261+10:00"}
{"id":"cortex-xhk.1","title":"Cross-project dependency tracking","description":"Enable beads to depend on beads in other projects. Pure Go code — no LLM needed.\n\n**Current limitation:**\nbd dep add only works within a single project's .beads/ directory. Dependencies are project-scoped. Project B's API integration task can't formally block on Project A's endpoint bead.\n\n**Implementation (all deterministic Go code):**\n\nExtend internal/beads/beads.go:\n- Cross-project bead ID format: {project}:{bead_id} (e.g. 'hg-website:cortex-abc')\n- When DependsOn contains a colon, it's a cross-project dep\n- ListBeads already returns bead IDs — extend to optionally include project prefix\n\nCreate internal/beads/crossdeps.go:\n```go\ntype CrossProjectGraph struct {\n    // project -\u003e bead_id -\u003e []dependency{project, bead_id}\n    Edges map[string]map[string][]CrossDep\n}\n\ntype CrossDep struct {\n    Project string\n    BeadID  string\n}\n\n// BuildCrossProjectGraph scans all enabled projects and builds unified dep graph\nfunc BuildCrossProjectGraph(projects map[string]config.Project) (*CrossProjectGraph, error)\n\n// FilterUnblockedCrossProject returns beads that are unblocked considering cross-project deps\nfunc (g *CrossProjectGraph) FilterUnblocked(project string, beadList []Bead) []Bead\n\n// GetCrossProjectBlockers returns what cross-project deps are blocking a bead\nfunc (g *CrossProjectGraph) GetBlockers(project, beadID string) []CrossDep\n```\n\nUpdate scheduler RunTick:\n- Build CrossProjectGraph once per tick (scans all projects)\n- Use FilterUnblocked instead of FilterUnblockedOpen when cross-deps exist\n- Log cross-project blockers\n\nUpdate internal/api/api.go:\n- GET /dependencies — show cross-project dependency graph\n- Include in project detail endpoint\n\n**No config changes needed** — cross-deps are expressed in bead DependsOn field using the project:bead_id format.\n\nAcceptance: Cross-project deps detected, enforced in scheduler, visible in API","status":"open","priority":1,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:39:19.26966189+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:39:19.26966189+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-xhk.1","depends_on_id":"cortex-xhk","type":"parent-child","created_at":"2026-02-17T17:39:19.2745517+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-xhk.10","title":"Predictive capacity planning","description":"Predict how long backlogs will take to clear based on velocity. Pure arithmetic — no LLM.\n\n**Implementation:**\n\nCreate internal/learner/forecast.go:\n```go\ntype Forecast struct {\n    Project        string\n    BacklogSize    int       // open beads\n    Velocity       float64   // beads/day (rolling 7d)\n    EstimatedDays  float64   // backlog / velocity\n    EstimatedSprints int     // estimated_days / sprint_length\n    SprintsOfRunway  int     // rate_limit_remaining / avg_dispatches_per_sprint\n    CapacityWarning  string  // 'rate limit will be exhausted in N days'\n}\n\n// ForecastProject predicts backlog completion for a project\nfunc ForecastProject(store *store.Store, project string, cadence *SprintCadence, budget ProjectBudget) (*Forecast, error)\n\n// ForecastPortfolio runs forecast for all projects\nfunc ForecastPortfolio(store *store.Store, projects map[string]config.Project, cadence *SprintCadence) ([]Forecast, error)\n```\n\nIncluded in:\n- Chief SM's PortfolioContext (for planning/retro prompts)\n- API: GET /forecast and GET /forecast/{project}\n- Daily standup (per-project scrum master mentions 'at current velocity, backlog clears in N days')\n\nAcceptance: Forecasts calculate from velocity+backlog, rate limit runway computed, available in API and prompts","status":"open","priority":3,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:41:30.290196833+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:41:30.290196833+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-xhk.10","depends_on_id":"cortex-xhk","type":"parent-child","created_at":"2026-02-17T17:41:30.294575172+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-xhk.10","depends_on_id":"cortex-xhk.2","type":"blocks","created_at":"2026-02-17T17:41:49.267352889+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-xhk.10","depends_on_id":"cortex-xhk.4","type":"blocks","created_at":"2026-02-17T17:41:49.424603376+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-xhk.11","title":"Unified backlog API endpoint","description":"API endpoint showing beads across all projects in one view. Pure Go code — query aggregation.\n\n**Implementation:**\n\nAdd to internal/api/api.go:\n\nGET /backlog — unified backlog across all projects\n- Query params: ?status=open\u0026project=X\u0026sort=priority\n- Returns beads from all enabled projects with project field added\n- Includes cross-project dependency info\n- Sorted by priority (respecting project priority weight)\n\nGET /backlog/stats — aggregate stats\n- Total open, in_progress, blocked across all projects\n- Per-project breakdown\n- Cross-project blockers count\n\nGET /portfolio — high-level portfolio view\n- Per-project: open/progress/blocked/velocity\n- Overall capacity: rate limit used/remaining\n- Current sprint number and day\n- Next ceremony time\n\nNo LLM needed — this is query aggregation and JSON serialization.\n\nAcceptance: Endpoints return correct cross-project data, filtering works, sorted by priority","status":"open","priority":3,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:41:39.388353475+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:41:39.388353475+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-xhk.11","depends_on_id":"cortex-xhk","type":"parent-child","created_at":"2026-02-17T17:41:39.390504032+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-xhk.11","depends_on_id":"cortex-xhk.1","type":"blocks","created_at":"2026-02-17T17:41:49.577448584+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-xhk.2","title":"Aligned sprint cadence across projects","description":"Align all projects to a shared sprint cadence. Pure Go code — scheduling logic.\n\n**Current state:**\nEach project ticks independently. Sprint planning day/time is per-project. No concept of a shared sprint.\n\n**Implementation:**\n\nAdd to config:\n```toml\n[cadence]\nsprint_length = \"1w\"           # 1w, 2w\nsprint_start_day = \"Monday\"\nsprint_start_time = \"09:00\"\ntimezone = \"UTC\"\n```\n\nCreate internal/scheduler/cadence.go:\n```go\ntype SprintCadence struct {\n    Length    time.Duration\n    StartDay time.Weekday\n    StartTime string  // HH:MM\n    Timezone *time.Location\n}\n\n// CurrentSprint returns the current sprint number and boundaries\nfunc (c *SprintCadence) CurrentSprint() (number int, start, end time.Time)\n\n// IsSprintBoundary returns true if we're within N minutes of sprint start/end\nfunc (c *SprintCadence) IsSprintBoundary(t time.Time, windowMinutes int) (isStart, isEnd bool)\n\n// SprintDay returns which day of the sprint we're on (1-indexed)\nfunc (c *SprintCadence) SprintDay(t time.Time) int\n\n// NextCeremony returns the next scheduled ceremony time\nfunc (c *SprintCadence) NextCeremony() (name string, at time.Time)\n```\n\nCeremony schedule (derived from cadence, no per-project config needed):\n- Sprint planning: sprint start day, start time\n- Daily standup: every day at start time\n- Sprint review: last day of sprint, start time\n- Sprint retro: last day of sprint, start time + 1h\n\nPer-project sprint_planning_day/time in a4s.9 becomes optional override, defaults to cadence.\n\nStore additions:\n- RecordSprintBoundary(sprintNumber, start, end)\n- GetCurrentSprintNumber() int\n\nAcceptance: Unified cadence, ceremonies derive from it, per-project override still works, sprint numbers tracked","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:39:32.081453679+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:39:32.081453679+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-xhk.2","depends_on_id":"cortex-xhk","type":"parent-child","created_at":"2026-02-17T17:39:32.087561951+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-xhk.3","title":"Implement Chief Scrum Master agent","description":"Create the Chief Scrum Master (Chief SM) — a coordination agent that sits above per-project scrum masters.\n\n**What requires LLM:** Reasoning about cross-project trade-offs, synthesizing patterns across teams, producing actionable coordination decisions. The Chief SM is the only agent that sees ALL projects simultaneously.\n\n**What is code (not LLM):** Agent creation, data gathering, prompt assembly, ceremony scheduling.\n\n**Implementation:**\n\nAdd Chief SM to internal/team/team.go:\n```go\n// New role (not per-project — global)\n\"chief-scrum\": `# Chief Scrum Master Agent\n\nYou are the Chief Scrum Master coordinating across all projects.\n\n## Responsibilities\n- Run multi-team sprint planning: allocate work across projects\n- Run overall retrospective: spot systemic patterns across teams\n- Mediate resource contention: when projects compete for capacity\n- Escalate impediments that individual scrum masters can't resolve\n- Ensure cross-project dependencies are tracked and unblocked\n\n## You communicate via Matrix in the coordination room\n- Summarize cross-team status\n- Flag systemic risks\n- Propose capacity allocation changes\n\n## You do NOT\n- Refine individual beads (that's the project scrum master)\n- Make product decisions (that's the human PO)\n`\n```\n\nAgent naming: 'cortex-chief-scrum' (not project-prefixed — it's global)\n\nCreate internal/scheduler/chief.go:\n```go\ntype ChiefSM struct {\n    store      *store.Store\n    dispatcher *dispatch.Dispatcher\n    cfg        *config.Config\n    logger     *slog.Logger\n}\n\n// GatherPortfolioContext builds context across ALL projects (code, not LLM)\nfunc (c *ChiefSM) GatherPortfolioContext() *PortfolioContext\n\ntype PortfolioContext struct {\n    Projects       []ProjectSummary  // per-project stats\n    CrossDeps      []CrossDepStatus  // unresolved cross-deps\n    RateLimitUsage RateLimitSummary  // global capacity state\n    ProviderHealth map[string]ProviderHealthSummary\n    SprintNumber   int\n    SprintDay      int\n}\n\ntype ProjectSummary struct {\n    Name           string\n    OpenBeads      int\n    InProgress     int\n    Blocked        int\n    CompletedThisSprint int\n    FailedThisSprint    int\n    Velocity       float64\n    ScrumMasterAgent string\n}\n```\n\nConfig:\n```toml\n[chief]\nenabled = true\nmatrix_room = \"!coordination:matrix.org\"   # separate room for cross-team coordination\nmodel = \"claude-opus-4-6\"                  # always Opus\n```\n\nThe Chief SM dispatches are always premium tier. It only runs for ceremonies (not per-tick), so rate limit impact is minimal.\n\nAcceptance: Chief SM agent exists, GatherPortfolioContext works, config parsed, agent created on startup","status":"open","priority":1,"issue_type":"feature","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:39:54.054416696+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:39:54.054416696+10:00","dependencies":[{"issue_id":"cortex-xhk.3","depends_on_id":"cortex-xhk","type":"parent-child","created_at":"2026-02-17T17:39:54.058618895+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-xhk.3","depends_on_id":"cortex-xhk.1","type":"blocks","created_at":"2026-02-17T17:41:47.700075134+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-xhk.3","depends_on_id":"cortex-xhk.2","type":"blocks","created_at":"2026-02-17T17:41:47.839437407+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-xhk.4","title":"Rate limit capacity budgeting per project","description":"Allocate rate limit budget across projects instead of first-come-first-served. Pure Go code — arithmetic and enforcement.\n\n**Current problem:**\nRate limits are global. If project A is high priority and project B is low priority, B can still exhaust the weekly cap before A gets its work done. The rate limiter doesn't know about project priority.\n\n**Implementation (all deterministic code):**\n\nConfig:\n```toml\n[rate_limits]\nwindow_5h_cap = 20\nweekly_cap = 200\n\n# Budget allocation (must sum to 100)\n[rate_limits.budget]\nhg-website = 60      # 60% of weekly cap = 120 dispatches\nother-project = 40   # 40% = 80 dispatches\n```\n\nIf no budget section exists, fall back to current behavior (shared pool).\n\nExtend internal/dispatch/ratelimit.go:\n```go\n// BudgetedCanDispatch checks project-specific budget before dispatching\nfunc (rl *RateLimiter) BudgetedCanDispatch(project string) (bool, string)\n\n// ProjectBudget returns remaining capacity for a project\nfunc (rl *RateLimiter) ProjectBudget(project string) (used, cap int)\n\n// RebalanceBudget allows Chief SM to temporarily shift allocation (e.g. 'all hands on A')\nfunc (rl *RateLimiter) RebalanceBudget(allocations map[string]int) error\n```\n\nStore query:\n- CountAuthedUsageByProject(project, window) — already have provider-level, add project grouping\n\nScheduler integration:\n- RunTick checks BudgetedCanDispatch(project) before picking provider\n- If project budget exhausted but global cap has room, log it but don't dispatch\n\nAPI addition:\n- GET /status includes per-project budget: used/cap/remaining\n\nAcceptance: Budget enforced per project, fallback to shared pool if unconfigured, rebalance API works","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:40:10.215643736+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:40:10.215643736+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-xhk.4","depends_on_id":"cortex-xhk","type":"parent-child","created_at":"2026-02-17T17:40:10.450122079+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-xhk.5","title":"Cross-project provider performance profiling","description":"Aggregate provider performance stats across all projects and detect patterns. Mostly Go code for stats, with optional LLM analysis in retro.\n\n**What is code:** Aggregating success/fail rates by provider × label/type across projects. Detecting statistical patterns (e.g. 'provider X fails \u003e50% on label:go'). Building skill profiles.\n\n**What is LLM (handled in overall retro, not here):** Interpreting why a provider fails and recommending what to do about it.\n\n**Implementation:**\n\nCreate internal/learner/profiles.go:\n```go\ntype ProviderProfile struct {\n    Provider     string\n    TotalDispatches int\n    SuccessRate  float64\n    AvgDuration  float64\n    // Performance by label\n    LabelStats   map[string]LabelPerformance\n    // Performance by bead type\n    TypeStats    map[string]LabelPerformance\n}\n\ntype LabelPerformance struct {\n    Label       string\n    Total       int\n    SuccessRate float64\n    AvgDuration float64\n    Trend       string // improving, stable, degrading\n}\n\n// BuildProviderProfiles aggregates stats across all projects\nfunc BuildProviderProfiles(store *store.Store, window time.Duration) (map[string]ProviderProfile, error)\n\n// DetectWeaknesses returns provider+label combos with \u003e40% failure rate and \u003e=3 samples\nfunc DetectWeaknesses(profiles map[string]ProviderProfile) []Weakness\n\ntype Weakness struct {\n    Provider    string\n    Label       string\n    FailureRate float64\n    SampleSize  int\n    Suggestion  string  // deterministic: 'deprioritize for label:go'\n}\n\n// ApplyProfileToTierSelection adjusts tier/provider selection based on profiles\n// e.g. if provider X is weak on label:go, skip it for Go beads even if it's in the right tier\nfunc ApplyProfileToTierSelection(profiles map[string]ProviderProfile, bead beads.Bead, candidates []string) []string\n```\n\nStore additions:\n- Dispatches already store provider and tier. Need to also store bead labels (add labels column to dispatches table) so we can query performance by label.\n- Query: GetProviderLabelStats(window) — group by provider, label, count success/fail\n\nIntegration:\n- Scheduler calls ApplyProfileToTierSelection when picking provider — filters out providers known to be weak for this bead's labels\n- Profiles rebuilt periodically (every N ticks or daily), cached in memory\n- Weaknesses included in portfolio context for Chief SM retro\n\nAcceptance: Profiles built from dispatch history, weaknesses detected, weak providers filtered from selection, data available for retro","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:40:28.427985135+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:40:28.427985135+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-xhk.5","depends_on_id":"cortex-xhk","type":"parent-child","created_at":"2026-02-17T17:40:28.431917212+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-xhk.6","title":"Multi-team sprint planning ceremony","description":"Chief SM runs a unified sprint planning across all projects. LLM for reasoning about allocation trade-offs.\n\n**What is code:** Gathering backlogs, calculating capacity, enforcing budget constraints, recording sprint plan.\n**What is LLM (Chief SM dispatch):** Reasoning about priority trade-offs, resolving cross-project conflicts, producing allocation rationale.\n\n**Implementation:**\n\nExtend internal/scheduler/chief.go:\n\nfunc (c *ChiefSM) RunMultiTeamPlanning(ctx):\n\nCode (before dispatch):\n1. Gather all project backlogs (unrefined + refined beads across all projects)\n2. Build cross-project dependency graph\n3. Calculate per-project capacity budget (from rate_limits.budget)\n4. Get provider profiles (what's working, what's weak)\n5. Get each project's sprint planning results if already run (from a4s.9)\n6. Package into PortfolioContext\n\nLLM (Chief SM dispatch at premium/Opus tier):\n7. Chief SM receives PortfolioContext + all backlogs\n8. Reviews cross-project dependencies: 'Project B needs endpoint from Project A — prioritize A's endpoint bead'\n9. Allocates capacity: 'Project A gets 60% this sprint (critical deadline), B gets 40%'\n10. Identifies conflicts: 'Both projects want premium tier for similar work — stagger them'\n11. Produces unified sprint plan sent to coordination Matrix room\n\nAfter dispatch (code):\n12. Record allocations in store\n13. Update rate limit budgets if Chief SM recommended rebalancing\n\nScheduling: runs at sprint start (from cadence config), BEFORE individual project sprint planning.\nOrder: Chief SM multi-team planning → per-project scrum master sprint planning (a4s.9)\n\nPrompt template: 'sprint_planning_multi' — includes all project backlogs, cross-deps, capacity, profiles.\n\nAcceptance: Chief SM sees all projects, reasons about allocation, produces unified plan, runs before per-project planning","status":"open","priority":1,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:40:43.697836427+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:40:43.697836427+10:00","dependencies":[{"issue_id":"cortex-xhk.6","depends_on_id":"cortex-xhk","type":"parent-child","created_at":"2026-02-17T17:40:43.727751168+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-xhk.6","depends_on_id":"cortex-xhk.3","type":"blocks","created_at":"2026-02-17T17:41:47.987719672+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-xhk.6","depends_on_id":"cortex-xhk.4","type":"blocks","created_at":"2026-02-17T17:41:48.123624311+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-xhk.6","depends_on_id":"cortex-xhk.5","type":"blocks","created_at":"2026-02-17T17:41:48.26979425+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-xhk.7","title":"Overall retrospective ceremony","description":"Chief SM runs a meta-retrospective across all projects. LLM for pattern analysis.\n\n**What is code:** Aggregating per-project retro data, cross-project stats, systemic metrics.\n**What is LLM (Chief SM dispatch):** Spotting systemic patterns, producing cross-cutting recommendations.\n\n**Implementation:**\n\nExtend internal/scheduler/chief.go:\n\nfunc (c *ChiefSM) RunOverallRetro(ctx):\n\nCode (data gathering):\n1. Collect per-project RetroReports (from retro.go)\n2. Aggregate: total dispatches, failures, velocity across all projects\n3. Build cross-project provider profiles (from profiles.go)\n4. Get cross-project dependency resolution stats: how many cross-deps resolved this sprint, how many are still blocking\n5. Rate limit usage: per-project budget utilization, any project starved?\n6. Compare sprint plan vs actual across all projects\n\nLLM (Chief SM dispatch at premium/Opus tier):\n7. Chief SM receives all aggregated data\n8. Identifies systemic patterns:\n   - 'Provider X is underperforming across ALL projects, not just one'\n   - 'Cross-project deps are the #1 blocker — 3 beads blocked for \u003e3 days'\n   - 'Tier misclassification is 30% globally — complexity detection needs tuning'\n   - 'Project A is starving Project B of capacity — rebalance budget'\n9. Produces action items:\n   - Code-level: 'adjust complexity thresholds' (can create beads)\n   - Config-level: 'deprioritize provider X' (can suggest config changes)\n   - Process-level: 'require estimates on all beads before sprint planning'\n10. Sends to coordination Matrix room\n\nScheduling: runs at sprint end (from cadence), AFTER per-project retros.\nOrder: per-project retros (a4s.11) → Chief SM overall retro\n\nAcceptance: Chief SM analyzes cross-project patterns, produces systemic recommendations, creates follow-up beads if needed","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:40:57.016207201+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:40:57.016207201+10:00","dependencies":[{"issue_id":"cortex-xhk.7","depends_on_id":"cortex-xhk","type":"parent-child","created_at":"2026-02-17T17:40:57.018624225+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-xhk.7","depends_on_id":"cortex-xhk.3","type":"blocks","created_at":"2026-02-17T17:41:48.515419988+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-xhk.7","depends_on_id":"cortex-xhk.5","type":"blocks","created_at":"2026-02-17T17:41:48.71094653+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-xhk.8","title":"Unified sprint review","description":"Chief SM produces a single sprint review summarizing what shipped across all projects. LLM for narrative synthesis.\n\n**What is code:** Gathering completed beads, velocity, stats per project.\n**What is LLM (Chief SM dispatch):** Synthesizing a coherent narrative of what shipped, for the human PO.\n\n**Implementation:**\n\nExtend internal/scheduler/chief.go:\n\nfunc (c *ChiefSM) RunUnifiedReview(ctx):\n\nCode:\n1. For each project: list beads closed during this sprint\n2. Calculate: planned (from sprint plan) vs delivered\n3. Get velocity per project and overall\n4. Identify scope changes mid-sprint\n\nLLM (Chief SM at premium tier):\n5. Produce portfolio-level narrative:\n   - What shipped across all projects (grouped by project)\n   - Overall completion rate: N/M planned beads across all projects\n   - Cross-project milestones: 'Project A's API is done, unblocking Project B'\n   - Risks carrying into next sprint\n6. Send to coordination Matrix room (and optionally to per-project rooms)\n\nScheduling: sprint end, before retro.\nOrder: unified review → per-project retros → overall retro\n\nAcceptance: Narrative covers all projects, planned vs delivered, sent to Matrix","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:41:06.716314596+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:41:06.716314596+10:00","dependencies":[{"issue_id":"cortex-xhk.8","depends_on_id":"cortex-xhk","type":"parent-child","created_at":"2026-02-17T17:41:06.721542958+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-xhk.8","depends_on_id":"cortex-xhk.3","type":"blocks","created_at":"2026-02-17T17:41:48.847793786+10:00","created_by":"Simon Heikkila"},{"issue_id":"cortex-xhk.8","depends_on_id":"cortex-xhk.2","type":"blocks","created_at":"2026-02-17T17:41:49.122137158+10:00","created_by":"Simon Heikkila"}]}
{"id":"cortex-xhk.9","title":"Definition of Done enforcement","description":"Configurable per-project DoD that the ops/qa agent checks. Pure Go code — run commands, check results.\n\n**Implementation:**\n\nConfig:\n```toml\n[projects.hg-website.dod]\nchecks = [\n    \"go test ./...\",\n    \"go vet ./...\",\n    \"golangci-lint run\",\n]\ncoverage_min = 70          # optional: fail if coverage \u003c N%\nrequire_estimate = true    # bead must have estimate before closing\nrequire_acceptance = true  # bead must have acceptance criteria\n```\n\nCreate internal/scheduler/dod.go:\n```go\ntype DoDChecker struct {\n    checks          []string\n    coverageMin     int\n    requireEstimate bool\n    requireAcceptance bool\n}\n\n// CheckDoD runs all DoD checks in the project workspace. Returns pass/fail with details.\n// This is called by the scheduler when a dispatch completes (before marking bead as done).\nfunc (d *DoDChecker) Check(ctx context.Context, workspace string, bead beads.Bead) (*DoDResult, error)\n\ntype DoDResult struct {\n    Passed  bool\n    Checks  []CheckResult  // per-command results\n    Failures []string       // human-readable failure reasons\n}\n\ntype CheckResult struct {\n    Command  string\n    ExitCode int\n    Output   string  // truncated\n    Passed   bool\n}\n```\n\nIntegration:\n- After ops/qa agent completes and before bd close, scheduler runs DoDChecker\n- If DoD fails, bead transitions back to stage:coding with failure notes\n- DoD results recorded in store for retro analysis\n- No LLM needed — this is running commands and checking exit codes\n\nAcceptance: DoD checks run on completion, failures block closing, results recorded, configurable per project","status":"open","priority":2,"issue_type":"task","owner":"simon.heikkila@gmail.com","created_at":"2026-02-17T17:41:18.931164144+10:00","created_by":"Simon Heikkila","updated_at":"2026-02-17T17:41:18.931164144+10:00","labels":["code"],"dependencies":[{"issue_id":"cortex-xhk.9","depends_on_id":"cortex-xhk","type":"parent-child","created_at":"2026-02-17T17:41:18.953268002+10:00","created_by":"Simon Heikkila"}]}
